# STM32简介

## 资源外设

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181106.png)

## 系统结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181107.png)

## 引脚定义

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181108.png)



# 模块知识点

## 旋转编码器

### 介绍

> •旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向
>
> •类型：机械触点式/霍尔传感器式/光栅式	
>
> ![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142133.png)
>

#### 正交波形

两个波形差相90度，通过判断哪个波形先，则可判断旋转的方向，所以带有双向波形的都能测方向，单相波形则不行

### 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142137.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142138.png)

> 注意：C口相当于一个普通的按键，当旋转按下时，相当于按键按下，接线和代码都与按键一样。

### 编程思想

> 编码器一般与两个定时器一起用，当GPIO口收到波形时触发定时器，通过波形的相位可以得知是左旋还是右旋。

> 左右旋区分：结果结构图，旋转时A,B口必有一个会置于高电平，另一个还处于低电平，转一下就是一个波形，所以一个口高电平打开通道，知道另一个口低电平则说明转动一次结束。

> 防抖：在打开通道的时候，加一个if判断触发口到低电平，再判断另一个口到低电平则说明一次转动结束。

##### 代码

``` c
void EXTI0_IRQHandler(void)
{
	if(EXTI_GetFlagStatus(EXTI_Line0)==SET)  //一个口打开通道
	{
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==0) //直到触发口到低电平
		{
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==1)//再直到另一口低电平
			{
                //则执行内容
			}
		}
		EXTI_ClearITPendingBit(EXTI_Line0); //清除标志位
	}
}

void EXTI1_IRQHandler(void) //另一个口作为触发口
{
	if(EXTI_GetFlagStatus(EXTI_Line1)==SET)
	{
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==0)
		{
			if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==1)
			{
                //内容
			}
		}
		EXTI_ClearITPendingBit(EXTI_Line1);
	}
}
```





## 对射式红外线

### 作用

> 当红外线被遮挡时，DO口则会输出高电平，利用这个特性，在GPIO中读取然后做出相应操作即可

## 舵机

### 简介

•舵机是一种根据输入PWM信号占空比来控制输出角度的装置

•输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181130.jpg)

### 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181131.jpg)



![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181132.png)



### 编程思路

舵机的整体其实就是PWM的使用，输出固定周期的波形即可驱动舵机

* 先根据PWM结构图配置好PWM的结构
* 然后根据舵机需要20ms的周期计算
* 然后配置好GPIO口，使波形输出到制定GPIO口

舵机其实就是PWM输出对应的波形即可，而PWM本质就是定时器固定时间输出波形。

所以编程的思路就是定时器TIM和CRR结合在一起，通过CRR的值改变TIM输出的高电压而已。

所以环境的配置主要就是TIM和输出比较，TIM需要开启时钟。

而运行就是靠一个函数改变CRR的值即可。

## TB6612

•直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转

•直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作

•TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向

### 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181138.png)





![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181139.png)

## MPU6050

### 简介

•MPU6050是一个6轴姿态传感器，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角[^欧拉角]，常应用于平衡车、飞行器等需要检测自身姿态的场景

•3轴加速度计（Accelerometer）：测量X、Y、Z轴的加速度

•3轴陀螺仪传感器（Gyroscope）：测量X、Y、Z轴的角速度[^角速度]

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291419.png)

> [^欧拉角]:欧拉角有俯仰，翻滚，偏航。

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291427.png)

> 加速度计具有静态稳定性，不具有动态稳定性
>
> 相当于弹簧测力计测加速度的原理

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291428.png)

> 陀螺仪具有动态稳定性，不具有静态稳定性。
>
> [^角速度]:绕x、y、z轴旋转的角速度

### MPU6050参数

•16位ADC采集传感器的模拟信号，量化范围：-32768~32767

•加速度计满量程选择：±2、±4、±8、±16（g）

•陀螺仪满量程选择： ±250、±500、±1000、±2000（°/sec）

•可配置的数字低通滤波器

•可配置的时钟源

•可配置的采样分频

•I2C从机地址：1101000（AD0=0）

​						 1101001（AD0=1）

> 如果将从机地址转化为16进制，高3位和低4位切开，则为0x68

> 因为AD值的范围是一定的，所以满量程选的越小，测量就会越细腻。
>
> AD值和加速器是线性关系，一一对应的，用AD值求加速度，只需要乘一个系数就可以。
>
> 数字低通滤波器：可以通过配置该寄存器来选择对输出数据进行低通滤波。

### 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291454.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291455.png)

> 右边是芯片，左下角是排插，左上角是一个LDO，低压差线稳压器。

### 模块框图

​	![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291459.png)

### 程序

#### 思路

> 先配置好I^2^C底层通信，因为要给MPU6050初始化，所以要配置MPU的寄存器，所以先用I2C封装读和写的寄存器，然后利用封装函数来配写MPU的寄存器来初始化，再利用这些封装函数对MPU数据寄存器进行读写，获得陀螺仪和加速度计的值。

#### 程序

```c
#ifndef __MPU6050_REG_H
#define __MPU6050_REG_H

#define	MPU6050_SMPLRT_DIV		0x19
#define	MPU6050_CONFIG			0x1A
#define	MPU6050_GYRO_CONFIG		0x1B
#define	MPU6050_ACCEL_CONFIG	0x1C

#define	MPU6050_ACCEL_XOUT_H	0x3B
#define	MPU6050_ACCEL_XOUT_L	0x3C
#define	MPU6050_ACCEL_YOUT_H	0x3D
#define	MPU6050_ACCEL_YOUT_L	0x3E
#define	MPU6050_ACCEL_ZOUT_H	0x3F
#define	MPU6050_ACCEL_ZOUT_L	0x40
#define	MPU6050_TEMP_OUT_H		0x41
#define	MPU6050_TEMP_OUT_L		0x42
#define	MPU6050_GYRO_XOUT_H		0x43
#define	MPU6050_GYRO_XOUT_L		0x44
#define	MPU6050_GYRO_YOUT_H		0x45
#define	MPU6050_GYRO_YOUT_L		0x46
#define	MPU6050_GYRO_ZOUT_H		0x47
#define	MPU6050_GYRO_ZOUT_L		0x48

#define	MPU6050_PWR_MGMT_1		0x6B
#define	MPU6050_PWR_MGMT_2		0x6C
#define	MPU6050_WHO_AM_I		0x75

#endif
```



```c
#include "stm32f10x.h"                  // Device header
#include "MyI2C.h"
#include "MPU6050_Reg.h"

#define MPU6050_ADDRESS		0xD0		//MPU6050的I2C从机地址

/**
  * 函    数：MPU6050写寄存器
  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述
  * 参    数：Data 要写入寄存器的数据，范围：0x00~0xFF
  * 返 回 值：无
  */
void MPU6050_WriteReg(uint8_t RegAddress, uint8_t Data)
{
	MyI2C_Start();						//I2C起始
	MyI2C_SendByte(MPU6050_ADDRESS);	//发送从机地址，读写位为0，表示即将写入
	MyI2C_ReceiveAck();					//接收应答
	MyI2C_SendByte(RegAddress);			//发送寄存器地址
	MyI2C_ReceiveAck();					//接收应答
	MyI2C_SendByte(Data);				//发送要写入寄存器的数据
	MyI2C_ReceiveAck();					//接收应答
	MyI2C_Stop();						//I2C终止
}

/**
  * 函    数：MPU6050读寄存器
  * 参    数：RegAddress 寄存器地址，范围：参考MPU6050手册的寄存器描述
  * 返 回 值：读取寄存器的数据，范围：0x00~0xFF
  */
uint8_t MPU6050_ReadReg(uint8_t RegAddress)
{
	uint8_t Data;
	
	MyI2C_Start();						//I2C起始
	MyI2C_SendByte(MPU6050_ADDRESS);	//发送从机地址，读写位为0，表示即将写入
	MyI2C_ReceiveAck();					//接收应答
	MyI2C_SendByte(RegAddress);			//发送寄存器地址
	MyI2C_ReceiveAck();					//接收应答
	
	MyI2C_Start();						//I2C重复起始
	MyI2C_SendByte(MPU6050_ADDRESS | 0x01);	//发送从机地址，读写位为1，表示即将读取
	MyI2C_ReceiveAck();					//接收应答
	Data = MyI2C_ReceiveByte();			//接收指定寄存器的数据
	MyI2C_SendAck(1);					//发送应答，给从机非应答，终止从机的数据输出
	MyI2C_Stop();						//I2C终止
	
	return Data;
}

/**
  * 函    数：MPU6050初始化
  * 参    数：无
  * 返 回 值：无
  */
void MPU6050_Init(void)
{
	MyI2C_Init();									//先初始化底层的I2C
	
	/*MPU6050寄存器初始化，需要对照MPU6050手册的寄存器描述配置，此处仅配置了部分重要的寄存器*/
	MPU6050_WriteReg(MPU6050_PWR_MGMT_1, 0x01);		//电源管理寄存器1，取消睡眠模式，选择时钟源为X轴陀螺仪
	MPU6050_WriteReg(MPU6050_PWR_MGMT_2, 0x00);		//电源管理寄存器2，保持默认值0，所有轴均不待机
	MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x09);		//采样率分频寄存器，配置采样率
	MPU6050_WriteReg(MPU6050_CONFIG, 0x06);			//配置寄存器，配置DLPF
	MPU6050_WriteReg(MPU6050_GYRO_CONFIG, 0x18);	//陀螺仪配置寄存器，选择满量程为±2000°/s
	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, 0x18);	//加速度计配置寄存器，选择满量程为±16g
}

/**
  * 函    数：MPU6050获取ID号
  * 参    数：无
  * 返 回 值：MPU6050的ID号
  */
uint8_t MPU6050_GetID(void)
{
	return MPU6050_ReadReg(MPU6050_WHO_AM_I);		//返回WHO_AM_I寄存器的值
}

/**
  * 函    数：MPU6050获取数据
  * 参    数：AccX AccY AccZ 加速度计X、Y、Z轴的数据，使用输出参数的形式返回，范围：-32768~32767
  * 参    数：GyroX GyroY GyroZ 陀螺仪X、Y、Z轴的数据，使用输出参数的形式返回，范围：-32768~32767
  * 返 回 值：无
  */
void MPU6050_GetData(int16_t *AccX, int16_t *AccY, int16_t *AccZ, 
						int16_t *GyroX, int16_t *GyroY, int16_t *GyroZ)
{
	uint8_t DataH, DataL;								//定义数据高8位和低8位的变量
	
	DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);		//读取加速度计X轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);		//读取加速度计X轴的低8位数据
	*AccX = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);		//读取加速度计Y轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);		//读取加速度计Y轴的低8位数据
	*AccY = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);		//读取加速度计Z轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);		//读取加速度计Z轴的低8位数据
	*AccZ = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);		//读取陀螺仪X轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);		//读取陀螺仪X轴的低8位数据
	*GyroX = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);		//读取陀螺仪Y轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);		//读取陀螺仪Y轴的低8位数据
	*GyroY = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	
	DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);		//读取陀螺仪Z轴的高8位数据
	DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);		//读取陀螺仪Z轴的低8位数据
	*GyroZ = (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
}

```

## W24Q64

### 简介

•W25Qxx系列是一种低成本、小型化、使用简单的非易失性存储器，常应用于数据存储、字库存储、固件程序存储等场景

•存储介质：Nor Flash（闪存）

•时钟频率：80MHz / 160MHz (Dual SPI) / 320MHz (Quad SPI)

•存储容量（24位地址）：

 W25Q40：  4Mbit / 512KByte

 W25Q80：  8Mbit / 1MByte

 W25Q16：  16Mbit / 2MByte

 W25Q32：  32Mbit / 4MByte

 W25Q64：  64Mbit / 8MByte

 W25Q128： 128Mbit / 16MByte

 W25Q256： 256Mbit / 32MByte

### 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311442.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311443.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311444.png)

### 框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311449.png)

### Flash写入注意

写入操作时：

•写入操作前，必须先进行写使能

•每个数据位只能由1改写为0，不能由0改写为1

•写入数据前必须先擦除，擦除后，所有数据位变为1

•擦除必须按最小擦除单元进行

•连续写入多字节时，最多写入一页的数据，超过页尾位置的数据，会回到页首覆盖写入

•写入操作结束后，芯片进入忙状态，不响应新的读写操作

读取操作时：

直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取

## ESP8266-01S

### 简介

ESP8266 是串口型 WIFI，速度比较低，不能用来传输图像或者视频这些大容量的数据，主要应用于数据量传输比较少的场合，比如温湿度信息，一些传感器的开关量等。

### AP/STA模式

ESP8266为一个WiFi透传模块，和蓝牙透传模块具有主从两种工作模式一样，也具有两种工作模式：STA模式（Station）和AP模式（Access Point），一般WiFi模块还会有一个STA+AP模式，即可以在两种模式下切换的状态。
  AP模式下，WiFi模块产生热点，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由/网桥工作在该模式下。该模式对应TCP传输协议中的服务端（TCP Server）。
  STA模式下，WiFi模块为连接到无线网络的终端（站点），可以连接到AP，一般无线网卡工作在STA模式下。该模式对应TCP传输协议中的客户端（TCP Client）。

两种模式的差异在于：AP是自己发放的热点与设备建立联系，STA是自己和设备连同一个WIF建立的联系

### TCP/UDP/透传

TCP
TCP是一种面向连接的，提供可靠交付服务和全双工通信的，基于字节流的端到端的传输层通信协议。

TCP在传输数据之前必须先建立连接，数据传输结束后要释放连接。
每一条TCP连接只能有2个端点，故TCP不提供广播或多播服务。
TCP提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。
TCP是面向字节流的。虽然应用进程和TCP的交互是一次一个数据块(大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传输的字节流的含义。
UDP
UDP是一种无连接的，尽最大努力交付的，基于报文的端到端的传输层通信协议

UDP，在发送数据之前不需要建立连接。
UDP不保证可靠交付，主机不需要位置复杂的连接状态。
UDP是面向报文的。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的的边界，即应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收端，UDP一次交付一个完整的报文。
UDP没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。
UDP支持一对一、一对多、多对一和多对多的交互通信。
UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。
透传
透传，又称透明传输，具体来说就是“输入即输出（如从WiFi模块串口输入的字符会透传到服务器端）”，数据不改变，不同协议之间的转换（如串口到WiFi、蓝牙等）由模块完成。使用者无需关心内部具体实现，因此模块对于使用者是“透明的”、似乎不存在的（因为可无视中间的实现原理）。一个高度封装的模块，应该隐藏内部实现细节，仅对外提供使用接口。

### AT指令

> 指令：AT
>
> 测试AT是否ok
>
> 
>
> 指令：AT+GMR
>
> 返回固件版本信息
>
> 
>
> 指令：AT+RST
>
> 软重启模组
>
> 
>
> 指令：AT+RESTORE
>
> 重置模组为出厂设置
>
> 
>
> 指令：AT+CWJAP
>
> 连接WIFI
>
> AT+CWJAP="WIFI名称","WiFi密码"
>
> 
>
> 指令：AT
>
> 测试AT是否ok
>
> 
>
> 指令：AT+CWMODE=X
>
> 选择配置模式，X=1为Station模式，X=2为AP模式
>
> AP配置：AT+CWSAP="TCP_Server","12345678",5,4 
>
> Station配置：AT+CWJAP="TCP_Server","12345678"  //连接AP
>
> 配置AP信息
>
> 
>
> 指令：AT+CIFSR
>
> 查询本机IP地址
>
> 
>
> 指令：AT+CIPMUX=X
>
> X=0开启单链接，X=1为开启多链接
>
> 
>
> 指令：`AT+CIPSERVER=1,8080`
>
> X=0为关闭服务器，X=1为开启服务器
>
> AT+CIPSTART="TCP","192.168.4.1",333 //连接到TCP服务器
>
> AT+CIPSTART="UDP","192.168.4.2",8002,8001,0  //开启UDP连接
>
> 
>
> 指令：AT+CIPSEND=10
>
> 发送数据，发送10个字节的数据到服务器
>
> 
>
> 指令：AT+AIPCLOSE
>
> 关闭UDP连接
>
> 
>
> 指令：AT+CWSAP=X
>
> 配置AP参数，X=0-OPEN，1-WEP，2-WPA_PSK，3-WPA2_PSK，4-WPA_WPA2_PSK
>
> AT+CWSAP="ESP8266","12345678",1,3
>
> 
>
> 指令：AT+CWLIF
>
> 查看已接入设备的IP



### AP主机模式收发

#### 简介

通过ESP8266打开热点创建服务器，其他设备连接热点，从而与ESP8266建立WIFI通信

#### 过程

串口中输入AT指令配置

1. 配置为AP模式

    >发送命令：`AT+CWMODE=3 `或 `AT+CWMODE=2` (设置指令)
    >
    >指令：AT+CWMODE=
    >
    >说明：:1-Station模式，2-AP模式，3-AP兼Station模式
    >
    >响应：OK

2. 配置AP参数

> 发送命令：AT+CWSAP="ESP8266","12345678",1,3 (设置指令)
>
> 指令：AT+ CWSAP= ,,,
>
> 说明：指令只有在AP模式开启后有效
>
> :字符串参数，接入点名称
>
> :字符串参数，密码最长64字节，ASCII
>
> :通道号
>
> < ecn >:0-OPEN，1-WEP，2-WPA_PSK，3-WPA2_PSK，4-WPA_WPA2_PSK
>
> 响应：OK

3. 连接WIFI

> wifi模块的热点已经打开，可以连接

4. 开启多连接模式

> 发送命令：`AT+CIPMUX=1`(设置指令)
>
> 指令：AT+CIPMUX=
>
> 说明：:0-单路连接模式，1-多路连接模式
>
> 响应：OK

5. 创建服务器

> 发送命令：`AT+CIPSERVER=1,8080`(设置指令)
>
> 指令：AT+CIPSERVER=[,]
>
> 说明：:0-关闭 server 模式，1-开启 server 模式
>
> :端口号，缺省值为 333
>
> 响应：OK

6. ##### 设置服务器超时时间

> 发送命令 `AT+CIPSTO=2880` (设置指令)
>
> 指令：AT+CIPSTO=
>
> 说明：:服务器超时时间，0~2880，单位为 s
>
> 响应：OK

7. 查看当前连接

> 发送命令 AT+CIPSTATUS (执行指令)
>
> 指令：AT+CIPSTATUS
>
> 响应：STATUS: + CIPSTATUS:,,,,
>
>  OK
>
> 说明：
>
> :连接的 id 号 0-4
>
> :字符串参数，类型 TCP 或 UDP
>
> :字符串参数，IP 地址
>
> :端口号
>
> : 0-本模块做 client 的连接，1-本模块做 server 的连接

8. 向连接发送数据

> 发送命令 AT+CIPSEND=0,6(设置指令) （通过上一条指令 AT+CIPSTATUS 得知 ID=0）
>
> 指令：
>
> 1)单路连接时(+CIPMUX=0)，指令为：AT+CIPSEND=
>
> 2)多路连接时(+CIPMUX=1) ，指令为： AT+CIPSEND= ,
>
> 响应：
>
> 收到此命令后先换行返回”>”，然后开始接收串口数据
>
> 当数据长度满 length 时发送数据。
>
> 如果未建立连接或连接被断开，返回 ERROR
>
> 如果数据发送成功，返回 SEND OK
>

#### 总结

先打开AP接口，然后创建服务器，设备连接服务器，然后通过发送数据的AT指令发送数据

### AP副机模式收发

#### 简介

通过ESP8266打开热点，其他设备连接热点，其他设备建立服务器，ESP8266连接，从而建立WIFI通信

#### 过程

串口中输入AT指令配置

1. 配置为AP模式

    >发送命令：`AT+CWMODE=3 `或 `AT+CWMODE=2` (设置指令)
    >
    >指令：AT+CWMODE=
    >
    >说明：:1-Station模式，2-AP模式，3-AP兼Station模式
    >
    >响应：OK

2. 配置AP参数

> 发送命令：AT+CWSAP="ESP8266","12345678",1,3 (设置指令)
>
> 指令：AT+ CWSAP= ,,,
>
> 说明：指令只有在AP模式开启后有效
>
> :字符串参数，接入点名称
>
> :字符串参数，密码最长64字节，ASCII
>
> :通道号
>
> < ecn >:0-OPEN，1-WEP，2-WPA_PSK，3-WPA2_PSK，4-WPA_WPA2_PSK
>
> 响应：OK

3. 连接WIFI

> wifi模块的热点已经打开，可以连接

4. 在主机创建服务器

> 电脑的网络调试助手可以建立服务器并开启监听模式

5. 开启多连接模式

> 发送命令：`AT+CIPMUX=1`(设置指令)
>
> 指令：AT+CIPMUX=
>
> 说明：:0-单路连接模式，1-多路连接模式
>
> 响应：OK

6. 建立TCP连接

> 发送命令 AT+CIPSTART=0,"TCP","192.168.4.2",8080 (设置指令)
>
> 指令：1)单路连接时(+CIPMUX=0)，指令为：AT+CIPSTART= ,,
>
> 2)多路连接时(+CIPMUX=1)，指令为：AT+CIPSTART=,,,
>
> 响应：如果格式正确且连接成功，返回 OK，否则返回 ERROR
>
> 如果连接已经存在，返回 ALREAY CONNECT
>
> 说明：:0-4，连接的 id 号
>
> :字符串参数，表明连接类型，”TCP”-建立 tcp 连接，”UDP”-建立 UDP 连接
>
> :字符串参数，远程服务器 IP 地址
>
> :远程服务器端口号

7. 发送数据

> 发送命令` AT+CIPSEND=0,10`(设置指令)（通过上一条指令 **AT+CIPSTART** 设置为 ID=0）
>
> 指令：1)单路连接时(+CIPMUX=0)，指令为：AT+CIPSEND=

#### 总结

先打开AP接口，然后电脑创建服务器，ESP连接服务器，然后通过发送数据的AT指令发送数据

### STA获取网络时间

####  大框

通过ESP8266访问苏宁网站[quan.suning.com/getSysTime.do](http://quan.suning.com/getSysTime.do)获取时间，然后返回给STM32

#### 步骤

1. 将ESP32设置为STA模式

```c\
AT+CWMODE=1
```

2. 将ESP8266设置为单路连接模式，因为穿透模式只能在单路连接模式上进行

```c
AT+CIPMUX=0
```

3. 连接WIFI

```c
AT+CWJAP="WIFI名称","WiFi密码"
```

4. 设置为透传模式

```c
AT+CIPMODE=1
```

5. 连接目标模拟器

```c
AT+CIPSTART="TCP","quan.suning.com",80
```

6. 发送数据

```c
AT+CIPSEND
```

7. 获取时间

```c
GET http://quan.suning.com/getSysTime.do HTTP/1.1
Host: quan.suning.com


```



# STM32时钟树

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171543.png)

> **`驱动外设的本质是操作寄存器，而寄存器是由D触发器构成，而触发器需要时钟才能改写值，所以要想操作寄存器必须开启对应外设的时钟`**

## 时钟树

### HSE时钟

**HSE**:**High Speed External Clock signal**高速的外部时钟

来源：无源晶振（4-16M)，通常使用8M.

作用：可不分频或者2分频作为PLL锁相环的输入，还可直接不分频作为系统时钟，128分频作为外设RTC时钟的输入。

控制：HSE晶体可以通过设置时钟控制寄存器RCC_CR中的HSEON位被启动和关闭，在时钟控制寄存器RCC_CR中的HSERDY位用来指示高速外部振荡器是否稳定。在启动时，直到这一位被硬件置'1'，时钟才被释放出来。

1. 来源![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/ffedb93f121ed24f32301fc904d81606.png)
2. 作用：![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/17bf222cf8eccd917afdcd57b47d1db0.png)
3. 控制：![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/0b4f574a666f0df8ba5f31e531a23849.png)

### HSI时钟

HSI：**High Speed Internal Clock signal**		高速的内部时钟

来源：芯片内部，大小为8M，当HSE故障时，系统时钟会自动切换到HSI，直到HSE启动成功

作用：可直接作为系统时钟或在2分频作为PLL输入。HSI RC振荡器能够在不需要任何外部器件的条件下提供系统时钟。它的启动时间比HSE晶体振荡器短。然而，即使在校准之后它的时钟频率精度仍较差。

控制：时钟控制寄存器中的HSIRDY位用来指示HSI RC振荡器是否稳定。在时钟启动过程中，直到这一位被硬件置'1'，HSI RC输出时钟才被释放。HSI RC可由时钟控制寄存器中的HISON位来启动和关闭就。如果HSE晶体振荡器失效，HSI会被作为备用时钟源。

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/326fca4e78884f130d1c261f8fa85f91.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/8af91bec617df130b6452d19b1777492.png)

### LSE时钟

**LSE**:low Speed External Clock signal，低速的外部时钟。

**来源**：芯片内部，LSE晶体是一个32.768kHz的低速外部晶体或陶瓷谐振器。它为实时时钟或者其他定时功能提供一个低功耗且精确的时钟源。

**作用**：直接作为RTC是时钟来源

**控制**：LSE晶体通过在备份域控制寄存器(RCC_BDCR)里的LSEON位启动和关闭。在备份域控制寄存器(RCC_BDCR)里的LSERDY指示LSE晶体振荡是否稳定。在启动阶段，直到这个位被硬件置’1’后，LSE时钟信号才被释放出来。

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/5e11f6fe2c32e92496df799473e10fc3.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/a742fa980e37f6891dfca0a260782f9c.png)



### LSI时钟

**LSI:** low Speed Internal Clock signal，低速的内部时钟。
**来源：**内部芯片，LSI RC担当一个低功耗时钟源的角色，它可以在停机和待机模式下保持运行，LSI时钟频率大约40kHz(在30kHz和60kHz之间)。
**作用：**为独立看门狗和自动唤醒单元(RTC)提供时钟
**控制：**LSI RC可以通过控制/状态寄存器(RCC_CSR)里的LSION位来启动或关闭在控制/状态寄存器(RCC_CSR)里的LSIRDY位指示低速内部振荡器是否稳定。在启动阶段，直到这个位被硬件设置为’1’后，此时钟才被释放。

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/38abb93432ae3c51b30db07803c3365f.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/517b6a3ad634378510c5a85208cf0be5.png)



### 锁相环PPLCK

**锁相环时钟：**PLLCLK
**来源**：选择HIS振荡器除2或HSE振荡器为PLL的输入时钟，和选择倍频因子，必须在其被激活前完成。一旦PLL被激活，这些参数就不能被改动。
**作用：**内部PLL可以用来倍频HSI RC的输出时钟或HSE晶体输出时钟(倍频数2~16倍)，而经过倍频变成PLLCLK可以作为系统时钟源
**控制**：寄存器RCC_CFGR：PLLXTPRE、PLLMUL、PLLSRC位,寄存器RCC_CR:PLLNO、PLLRDY详情看下图
**注意：**PLL时钟源头使用HIS/2的时候，PLLMUL最大只能 是16，这个时候PLLCLK最大只能是64M，小于ST官方推 荐的最大时钟72M。如果需要在应用中使用USB接口，PLL必须被设置为输出48或72MHZ时钟，用于提供48MHz的USBCLK时钟。
![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/914b7e7ce6666947694df9e5ea9f04b8.png)

### 系统时钟SYSCLK

- **系统时钟：SYSCLK，最高为72M（ST官方推荐的）**
- **来源：HSI、HSE、PLLCLK。**
- **控制：CFGR：SW**
- **注意：通常的配置是SYSCLK=PLLCLK=72M。**

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/0b4f574a666f0df8ba5f31e531a23849%20(1).png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/c1505edaf7421a08d15219ead084f8a5.png)

#### 流程

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/ea28d3a889ea6bb61933ad14857532c0.png)



### HCLK时钟

- **HCLK：AHB高速总线时钟，速度最高为72M。**
- **作用：为AHB总线的外设提供时钟、为Cortex系统定时器提供时钟（SysTick）、为内核提供时（FCLK）**。
- **来源：系统时钟分频得到，一般设置HCLK=SYSCLK=72M**
- **控制： CFGR：HPRE**

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/2b603cc72c96402e35d95c271b9f29b1.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/d42fb31848ac1010a25dd6da9aadf743.png)



### PCLK1时钟

- **PCLK1：APB1低速总线时钟，最高为36M。**
- **作用：为APB1总线的外设提供时钟。1或2倍频之后则为APB1总线的定时器2~7提供时钟，最大为72M。**
- **来源：HCLK分频得到，一般配置PCLK1=HCLK/2=36M**
- **控制： RCC_CFGR 时钟配置寄存器的PPRE1位**

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/ba4851d407d52f2e368e5170a7ad72c9.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/85e0e74b946dd1869c5cf1139cabb615.png)



### PCLK2时钟

PCLK2：APB2高速总线时钟，最高为72M。
作用：为APB2总线的外设提供时钟。为APB2总线的定时器1和8提供时钟，最大为72M。APB2分频器还有一路输出供ADC分频器使用，分频后送给ADC模块使用。
来源：HCLK分频得到，一般配置PCLK1=HCLK=72M
控制： RCC_CFGR 时钟配置寄存器的PPRE2位
![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/b1a739bfcfd6c29d425c587406fae83d.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/27c465e38034005a92ace9257924f0b3.png)



### RTC时钟

- **RTC时钟：为芯片内部的RTC外设提供时钟。**
- **来源：HSE_RTC（HSE分频得到）、LSE（外部32.768KHZ的 晶体提供）、LSI（32KHZ）。**
- **控制： RCC备份域控制寄存器RCC_BDCR：RTCSEL位控制**
- **独立看门狗时钟：IWDGCLK，由LSI提供**

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/b43c09167632de8bd6583cab090ec5df.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/949ac3759f40191fa19ce969816c6179.png)



### 时钟安全系统（CSS）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/165ca0979fb78b5e8dd7511db0484e4e.png)

**监视高速外部时钟HSE的工作状态。若HSE失效，会自动切换高速内部时钟HSI作为系统时钟的输入，保证系统的正常运行。一旦CSS被激活，并且HSE时钟出现故障，CSS中断就产生，并且NMI也自动产生。NMI将被不
断执行，直到CSS中断挂起位被清除。**

### MCO时钟输出

- **MCO：microcontroller clockoutput，微控制器时钟输出`引脚`，由PA8复用所得。可以把时钟信号输出供外部使用，也可以用示波器检测时钟信号的参数(峰峰值，频率…)**
- **来源：PLLCLK/2，HSE、HSI、SYSCLK**
- **控制：CRGR：MCO**

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/7d1a1da1de8fe7bc01decb3912ad0e97.png)

## 时钟配置函数

STM32上电执行的第一个程序就会执行启动文件（汇编代码编写）中的复位程序

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/8207844bef53e7e257f2be773d4dbb42.png)

### 执行复位程序

1. **调用SystemInit系统初始化函数完成系统时钟的配置(配置成72MHZ)**
2. **调用_main函数初始化堆栈指针，然后再调用C库函数main函数**

> **所以跳转到C语言的main函数时，已经完成了系统时钟(SYSCLK)的配置。**

### SystemInit系统时钟初始化函数

```c
void SystemInit (void)  //在system_stm32f10x.c中
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;

#ifdef STM32F10X_CL
  /* Reset PLL2ON and PLL3ON bits */
  RCC->CR &= (uint32_t)0xEBFFFFFF;

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x00FF0000;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
#endif /* STM32F10X_CL */
    
#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
  #ifdef DATA_IN_ExtSRAM
    SystemInit_ExtMemCtl(); 
  #endif /* DATA_IN_ExtSRAM */
#endif 

  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
  /* Configure the Flash Latency cycles and enable prefetch buffer */
  SetSysClock();

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
#endif 
}
```

**这里将系统时钟配置成官方推荐的72MHZ**。

步骤：
由外部晶振(HSE)提供的8MHz通过PLLXTPRE分频器不分频，输入到PLLSRC，然后通过PLLMUL锁相环进行9倍频后输出PLLCLK时钟(72MHZ)，然后通过系统时钟切换SW 将PLLCLK作为系统时钟(72MHZ)。然后通过AHB预分频器进行1分频得到AHB总线时钟(HCLK)，然后再分别经过APB1,APB2预分频器分别2分频，1分频，给APB1(PCLK1）APB2(PCLK2)总线提供时钟,进而给分别挂载在APB1,APB2总线的外设提供时钟
![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/869f3981c8d63d6a703f0106617be8bf.png)

```C
#if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
/* #define SYSCLK_FREQ_HSE    HSE_VALUE */
 #define SYSCLK_FREQ_24MHz  24000000
#else
/* #define SYSCLK_FREQ_HSE    HSE_VALUE */
/* #define SYSCLK_FREQ_24MHz  24000000 */ 
/* #define SYSCLK_FREQ_36MHz  36000000 */
/* #define SYSCLK_FREQ_48MHz  48000000 */
/* #define SYSCLK_FREQ_56MHz  56000000 */
#define SYSCLK_FREQ_72MHz  72000000
#endif
//这里想配置多少就把注释去掉就好了
```





# GPIO

## 简介

•GPIO（General Purpose Input Output）通用输入输出口

•可配置为8种输入输出模式

•引脚电平：0V~3.3V，部分引脚可容忍5V

•输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等

•输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

## GPIO 基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1281503.png)

## GPIO的位结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1281504.png)

## GPIO模式

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1281505.png)

> 上拉输入：IO口在无输入的情况下，保持高电平
>
> 下拉输入：IO口在无输入的情况下，保持低电平
>
> 浮空输入：浮空输入状态下，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。
>
> 模拟输入：输入信号不经施密特触发器直接接入，输入信号为模拟量而非数字量，其余输入方式输入数字量。
>
> 推挽输出： 用推挽输出模式，可以得到一个明确的高电平或者低电平，可以实现高低电平的快速切换。在实际使用时，经常用IO口的高低电平去驱动一个LED或者是蜂鸣器，使用的就是ＭＣＵ的推挽输出模式。
>
> 开漏输出： 开漏的线与特性：当多个开漏输出链接到一起，当它们全部都输出高电平时，总线上才是高电平，但凡有一个开漏输出引脚上是低电平，总线就会被拉低。而且开漏输出需要一个外置的电源，不能驱动一些模块。更多是用来检测线路状态

## 程序

### 函数库

```c
/*APIO时钟线*/
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);

/*定义*/
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);

/*结构体初始赋值*/
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);

/*获取输入电压*/
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); //获取一位
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);  //获取一字节

/*获取输出电压*/
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); //获取一位
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);	//获取一字节

/*拉高引脚电压*/
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);

/*拉低引脚电压*/
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);

/*将IO口与EXIT通道连接*/
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);

/*重映射*/
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);  //RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);

```



# 中断系统

## 中断的概念

> •中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行
>
> •中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源
>
> •中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回

## 中断执行流程

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142042.png)



## STM32中断

> •68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设[^中断]
>
> •使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级[^NVIC]

> [^中断]: STM32基本所有外设都能申请中断
> [^NVIC]: VIC就是用来分配中断的优先级的
>
> 

### 中断资源

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142054.png)



![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142052.png)



![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142053.png)



## NVIC(嵌套中断向量控制器)

### 基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142059.png)

> 所有的中断通入NVIC，后NVIC向CPU申请。

### NVIC优先级分组

>•NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级
>
>•抢占优先级高的可以中断嵌套[^抢占]，响应优先级高的可以优先排队[^响应]，抢占优先级和响应优先级均相同的按中断号排队
>
>![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142105.png)
>
>

> [^抢占]: 抢占优先级就是强制性执行
> [^响应]: 相当于插队，处理完这个中断再处理这个中断

#### 函数库

```c
/*打开第几组的NVIC*/
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);

/*NVIC定义*/
	void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
	NVIC_InitTypeDef NVIC_InitStruct；
    NVIC_InitStruct.NVIC_IRQChannel  //选择NVIC的通道
    NVIC_InitStructure.NVIC_IRQChannelCmd  //NVIC通道使能
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  //NVIC抢占优先级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority  //NVIC响应优先级
    
```

### 使用方法

* 确定好中断的通道
* 打开NVIC使能
* NVIC的定义函数
    * 在NVIC的定义函数中将中断和NVIC的通道连接在一起。
    * 设置抢占优先级和响应优先级

### 理解

NVIC是所有中断通向CPU的外设，设置好中断，然后将中断外设连接至NVIC，则达到指定中断条件时就会执行中断函数。

## EXTI外部中断

### EXTI简介

> •EXTI（Extern Interrupt）外部中断
>
> •EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序
>
> •支持的触发方式：上升沿/下降沿/双边沿/软件触发
>
> •支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断
>
> •通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒
>
> •触发响应方式：中断响应/事件响应

### 基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142113.png)



### AFIO复用IO口

> •AFIO主要用于引脚复用功能的选择和重定义
>
> •在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142117.png)

#### 用法

AFIO的寄存器是可以选择引脚到EXTI，但是关于这部分的函数是在GPIO的函数库中。

AFIO的主要功能还是重映射，通过提供的函数可以将引脚设置为重映射。

### EXTI内部框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1142119.png)



### 代码

#### 步骤

> 根据EXTI结构，将一路外设配置好即可
>
> * 配置RCC，将时钟线打开，打开GPIO和AFIO的时钟线
> * 配置GPIO环境，选择端口为输入模式
> * 配置AFIO，选择对应的GPIO连接到后面的EXTI。//AFIO的作用就是将GPIO的线连接到EXTI中
> * 配置EXTI，先将EXTI进行初始化，选择边沿触发方式，选择触发响应方式[^响应方式]。//EXTI是不用打开时钟线的
> * 配置NVIC，分配优先级。//因为它在内核中，所以也不用打开时钟
> * 最后通过NVIC，外部中断信号就能进入CPU了

[^响应方式]:中断响应和事件响应

#### 函数库

```c
/*定义EXTI*/
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);

/*结构体赋初始值*/
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);

/*获取标志位*/
FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);

/*清除标志位*/
void EXTI_ClearFlag(uint32_t EXTI_Line);

/*获取中断标志位*/
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);

/*清除中断标志位*/
void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
 
```

#### 环境的配置

> ```c
>  void Encoder_Init(void)
> {
>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//打开总体时钟
>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//在APB2寄存器上，打开时钟
>      
> 	/*GPIOB环境配置*/ //配置好GPIO接口
> 	GPIO_InitTypeDef GPIO_InitStruct;
> 	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_IPU;
> 	GPIO_InitStruct.GPIO_Pin= GPIO_Pin_0 | GPIO_Pin_1;//这里配置了两个口
> 	GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz;
> 	GPIO_Init(GPIOB,&GPIO_InitStruct);//主要是GPIO定义函数
> 
> 	/*AFIO环境配置*/ //AFIO的函数都在gpio.h的文件中
> 	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);//将GPIOB的两个口连接至AFIO
> 	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);
> 
> 	/*EXTI环境配置*/  //主要是EXTI的定义，因为EXTI是内部资源，所以不用时钟
> 	EXTI_InitTypeDef EXTI_InitStruct; 
> 	EXTI_InitStruct.EXTI_Line=EXTI_Line0|EXTI_Line1;
> 	EXTI_InitStruct.EXTI_LineCmd=ENABLE;
> 	EXTI_InitStruct.EXTI_Mode=EXTI_Mode_Interrupt;
> 	EXTI_InitStruct.EXTI_Trigger=EXTI_Trigger_Rising;
> 	EXTI_Init(&EXTI_InitStruct); //根据定义的参数完成即可
> 
> 	/*NVIC环境配置*/ //因为NVIC是内核，所以函数库是在misc.h中
> 	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//先进行分组
> 	NVIC_InitTypeDef NVIC_InitStruct;
> 	NVIC_InitStruct.NVIC_IRQChannel=EXTI0_IRQn;
> 	NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;
> 	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=1;//响应优先级
> 	NVIC_InitStruct.NVIC_IRQChannelSubPriority=1; //抢占优先级
> 	NVIC_Init(&NVIC_InitStruct); //根据定义的函数完成即可
> 	NVIC_InitStruct.NVIC_IRQChannel=EXTI1_IRQn; //选择
> 	NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;
> 	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=1;
> 	NVIC_InitStruct.NVIC_IRQChannelSubPriority=2;
> 	NVIC_Init(&NVIC_InitStruct);
> }
> 
> ```

> 注意：

> 其中pin14是可以改变的

#### 中断程序

``` c
void EXTI15_10_IRQHandler(void)  //这个名字建议在startup中寻找，通道名字是固定的
{
	if(EXTI_GetFlagStatus(EXTI_Line14)==SET)  //判断14号通道是否打开
	{
        //内容//
		EXTI_ClearFlag(EXTI_Line14);  //清除14号通道的标致位
	}
}

```

## 定时器中断

### TIM简介

> •TIM（Timer）定时器
>
> •定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断
>
> •16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时
>
> •不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能
>
> •根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型

### 定时器种类

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1161442.png)



* STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4

### 定时器结构图

#### 基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171525.png)





#### 基本定时器

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1161447.png)



> 整体可以分为2个部分，下部分3个结构构成了最基本的计数计时电路，所以叫做时基单元
>
> 下部分到上部分的线可以看作为直接连接了内部时钟线[^内部时钟]

##### 预分频器：

> 实际分频与分频数相差1

* [^内部时钟]:一般是系统的主频72MHz.

##### 自动重装寄存器:

存储目标值的寄存器，因为是16位的，所以写入的计数值最大的也是65535

##### 运行

当计数器达到了寄存器存的值，则会清0,，并且申请中断（向上折线箭头则表达会产生中断信号）。

计数值等于自动重装值产生的中断叫做“更新中断",之后会通往NVIC

向下的折线箭头表示会产生一个事件，叫做“更新事件”

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115095718.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115095846.png)

#### 通用定时器

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1161458.png)  



##### 计数模式：

向上计数模式

> 计数器数到自动加载值（TIMx_ARR计数器的内容），会产生一个计数器溢出的事件

向下计数模式

中央对齐模式

#### 高级定时器

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1161446.png)



### 时序

#### 预分频器时序

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171531.png)



* 计数器计数频率：CK_CNT = CK_PSC / (PSC + 1)
* 该时序图最好与基本定时器结构体一起看

#### 计数器时序

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171536.png)



* 计数器溢出频率：CK_CNT_OV = CK_CNT / (ARR + 1) = CK_PSC / (PSC + 1) / (ARR + 1)
* 中断标志位需要在程序中手动清0
* 计数器的预装时序可以自己选择

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171540.png)



![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171541.png)



> 影子寄存器让值暂时存着，让下一个值在下一周期再运行

#### RCC时钟树

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1171543.png)



### 程序

#### 思路

> * 找到定时器的基本结构图，并确定将结构图的路径打通
> * 打开RCC时钟线
> * 选择时钟模式
> * 配置时基单元
> * 配置输出中断控制，允许更新中断输出到NVIC
> * 配置NVIC的环境，并打开定时器中断的通道，分配一个优先级
> * 使能计数器

#### 库函数

``` c
/*恢复初始配置*/
void TIM_DeInit(TIM_TypeDef* TIMx);

/*时基单元初始化*/
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef*TIM_TimeBaseInitStruct);

/*将结构体变量赋一个默认值*/
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);

/*使能计数器*/
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);

/*使能中断输出信号*/
/*这个函数中可以选择中断源*/
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);

/*选择内部时钟*/
void TIM_InternalClockConfig(TIM_TypeDef* TIMx);

/*选择ITRx其他定时器的时钟*/
void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);

/*选择TIx捕获通道的时钟*/
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,uint16_t TIM_ICPolarity, uint16_t ICFilter);

/*选择ETR通过外部时钟模式1输入的时钟*/
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,uint16_t ExtTRGFilter);

/*选择ETR通过外部时钟模式2输入的时钟*/
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,  uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);

/*单独配置ETR引脚的预分频器、极性、滤波器这类的参数*/
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,uint16_t ExtTRGFilter);

/*单独写预分频值*/
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);

/*改变计数器的计数模式*/
void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);

/*自动重装器预装功能配置*/
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);

/*手动给计数值*/
void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);

/*给自动重装器写入一个值*/
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);

/*获取当前计数器的值*/
uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);

/*获取当前预分频值*/
uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);

/*获取标志位和清除标致位*/
FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);

```

#### 环境配置代码

``` c
/*初始化TIM2(通用定时器)*/
void Timer_Init(void)
{
    /*打开时钟线*/
    /*TIM2是APB1总线的外设*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	
    /*调用内部时钟*/
    TIM_InternalClockConfig(TIM2);
    
    /*配置时基单元*/
	TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,0x00);
    /*为了定义函数而定义的结构体并赋值*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;  
    /*时钟分频*/
	TIM_TimeBaseInitStruct.TIM_ClockDivision=TIM_CKD_DIV1;
    /*选择计数模式*/
	TIM_TimeBaseInitStruct.TIM_CounterMode=TIM_CounterMode_Up;
    /*决定定时时间的两个变量，可以参考计数器时序图中的公式*/
	TIM_InternalClockConfig(TIM2);
	TIM_TimeBaseInitStruct.TIM_Prescaler=7200-1;//预分频
    /*重复计数器*/
	TIM_TimeBaseInitStruct.TIM_RepetitionCounter=0;
	TIM_TimeBaseInit(TIM2,&TIM_TimeBaseInitStruct);  //定义函数
	TIM_ClearFlag(TIM2,TIM_FLAG_Update);
	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
    
    /*NVIC环境配置*/
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;
	NVIC_Init(&NVIC_InitStructure);
	
    /*启动定时器*/
	TIM_Cmd(TIM2,ENABLE);
}
```

#### 运行代码

``` c
void TIM2_IRQHandler(void)  //名字在启动文件中可以找到
{
	if(TIM_GetITStatus(TIM2,TIM_IT_Update)==SET)
	{
        /*内容*/
		TIM_ClearITPendingBit(TIM2,TIM_IT_Update); //清除标志位
	}
}
```

## PWM

### 输出比较

#### 简介

•OC（Output Compare）输出比较

•输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形

•每个高级定时器和通用定时器都拥有4个输出比较通道

•高级定时器的前3个通道额外拥有死区生成和互补输出的功能

#### PWM简介

•PWM（Pulse Width Modulation）脉冲宽度调制

•在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域

•PWM参数：频率 = 1 / TS      占空比 = TON / TS      分辨率 = 占空比变化步距

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115100243.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181054.png)



![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181055.png)



#### 输出比较通道(高级)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181101.png)



#### 输出比较通道(通用)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181102.png)



> [^REF]: eference 参考信号

#### 输出比较模式

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181112.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115100413.png)

### PWM基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1181118.png)

> •PWM频率： Freq = CK_PSC / (PSC + 1) / (ARR + 1)    //CK_PSC ->频率
>
> •PWM占空比： Duty = CCR / (ARR + 1)
>
> •PWM分辨率： Reso = 1 / (ARR + 1)    //经常设置为1，所以ARR一般为100

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115100702.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115100735.png)

#### 步骤

根据PWM结构图，知道要配置的环境。

PWM的本质就是，通过TIM定时器按时拉高拉低电压制造波形，所以将定时器配置好，将输出比较配置好，还有GPIO配置好就好了。然后通过一个函数改变CRR的值来达到改变波形的样子。

总共大概4步：

> * 配置时基单元
> * 配置输出比较单元
> * 配置GPIO
> * 调用函数用循环输出PWM

##### 细致步骤

* RCC开启时钟，打开TIM外设和GPIO外设的时钟
* 配置时基单元，包括前面的时钟源选择
  * 先通过函数选择时钟源，后面用TIM_Init()即可
* 配置输出比较单元
  * 先用定义函数，然后创建结构体，初始化结构体，将没有N的结构体赋值
* 配置GPIO口，初始化为复用推挽输出的配置
  * 具体是打开GPIOA_Pin_0
* 运行控制，启动计数器。
  * 是利用函数打开计数器

#### 函数库

``` c
/*配置输出比较模块*/
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);

/*结构体的参数定义*/
TIM_OCInitStructure.TIM_OCMode //输出比较模式
TIM_OCInitStructure.TIM_OCPolarity //极性选择，电平是否要取反
TIM_OCInitStructure.TIM_OutputState  //输出使能
TIM_OCInitStructure.TIM_Pulse;//初始的CRR值
    
/*给输出比较结构体赋一个默认值的*/
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);

/*配置强制输出模式*/
void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);

/*配置CCR寄存器的预装功能的*/
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);

/*用来配置快速使能的*/
void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);

/*外部事件时清除REF信号*/
void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);

/*单独设置输出比较极性的（带个N的就是高级定时器里互补通道的配置）*/
void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);

/*单独修改输出使能参数*/
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);

/*单独修改选择输出比较模式*/
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);

/*单独修改CCR寄存器值的函数*/
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);

/*仅在高级定时器中输出PWM时需要调用此函数，使能主输出，否则PWM不能正常输出*/
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);

/*单独改变psc值的函数，从而改变pwm的频率*/
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
```

### 呼吸灯境配置

``` c
void PWM_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);			//开启TIM2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			//开启GPIOA的时钟
	
	/*GPIO重映射*/
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);			//开启AFIO的时钟，重映射必须先开启AFIO的时钟
//	GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);			//将TIM2的引脚部分重映射，具体的映射方案需查看参考手册
//	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);		//将JTAG引脚失能，作为普通GPIO引脚使用
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		//GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);				//将PA0引脚初始化为复用推挽输出	
						                    	//受外设控制的引脚，均需要配置为复用模式		
	
	/*配置时钟源*/
	TIM_InternalClockConfig(TIM2);		//选择TIM2为内部时钟，若不调用此函数，TIM默认也为内部时钟
	
	/*时基单元初始化*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				//定义结构体变量
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;					//计数周期，即ARR的值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1;				//预分频器，即PSC的值
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;       //重复计数器，高级定时器才会用到
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); //将结构体变量交给TIM_TimeBaseInit，配置TIM2的时基单元
	
	/*输出比较初始化*/
	TIM_OCInitTypeDef TIM_OCInitStructure;							//定义结构体变量
	TIM_OCStructInit(&TIM_OCInitStructure);		//结构体初始化，若结构体没有完整赋值
												//则最好执行此函数，给结构体所有成员都赋一个默认值
												//避免结构体初值不确定的问题
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;			//输出比较模式，选择PWM模式1
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;		//输出极性，选择为高，若选择极性为低，则输出高低电平取反
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	//输出使能
	TIM_OCInitStructure.TIM_Pulse = 0;								//初始的CCR值
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);						//将结构体变量交给TIM_OC1Init，配置TIM2的输出比较通道1
	
	/*TIM使能*/
	TIM_Cmd(TIM2, ENABLE);			//使能TIM2，定时器开始运行
}
```

此时GPIOA0口就是PWM输出的口，因为我们用的是TIM2，TIM2-->A0

我们通过函数改变RCC的值即可达到改变占比，从而达到呼吸灯的效果

### PWM互补

```c
void PWM_Init(void)
{
	PWM1_CLOCK;
	PWM1_GPIO_CLOCK;
	PWM1N_GPIO_CLOCK;
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = PWM1_PIN|PWM2_PIN|PWM3_PIN;		
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(PWM_PIN_GPIO, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin = PWM1N_PIN|PWM2N_PIN|PWM3N_PIN;
	GPIO_Init(PWMN_PIN_GPIO, &GPIO_InitStructure);
	
	TIM_InternalClockConfig(TIM1);
	
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInitStructure.TIM_Period = ARR;
	TIM_TimeBaseInitStructure.TIM_Prescaler = PSC;
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM_USE, &TIM_TimeBaseInitStructure); 
	
	TIM_OCInitTypeDef TIM_OCInitStructure;
	TIM_OCStructInit(&TIM_OCInitStructure);
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState=TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState=TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCNPolarity=TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCIdleState=TIM_OCIdleState_Set;
	TIM_OCInitStructure.TIM_OCNIdleState=TIM_OCIdleState_Reset;
	TIM_OCInitStructure.TIM_Pulse = CCR1;
	TIM_OC1Init(TIM_USE, &TIM_OCInitStructure);
	TIM_OCInitStructure.TIM_Pulse = CCR2;
	TIM_OC2Init(TIM_USE, &TIM_OCInitStructure);
	TIM_OCInitStructure.TIM_Pulse = CCR3;
	TIM_OC3Init(TIM_USE, &TIM_OCInitStructure);
	TIM_CtrlPWMOutputs(TIM_USE,ENABLE);
	TIM_Cmd(TIM_USE, ENABLE);
}
```

值得注意的是输出互补信号只有高级定时器有，在stm32f103中只有定时器1才能输出互补信号，根据引脚定义图可以看是哪几个引脚输出互补信号，输出互补信号与正常的PWM输出信号只有在初始化PWM的TIM_OCInitTypeDef类型结构体略有不同，只需要将该结构体的互补使能打开，将带有N的结构体成员赋值即可。

### PWM死区

#### 作用：

当然，这是一个非常核心且重要的问题。为直流无刷电机驱动设置PWM死区时间，**不是一个可有可无的优化，而是一个关乎系统安全、效率和稳定性的必要措施。**
简单来说，**死区时间是防止功率桥臂“直通”的硬件保护机制。**

核心问题：什么是“直通”（Shoot-Through）？

要理解死区的好处，必须先理解它要解决的问题。

 a. 三相逆变桥的结构

驱动无刷电机的电路通常是一个**三相逆变桥**，由6个功率开关管（通常是MOSFET或IGBT）组成，分为上臂（High-Side）和下臂（Low-Side）。每一相（U, V, W）都由一个上臂和一个下臂开关管组成。
```
          +DC Bus (电源正极)
             |
        +----+----+
        |         |
      Q1(UH)    Q3(VH)    Q5(WH)   <-- 上臂开关管
        |         |         |
  U ----+         V ----+   W ----+
        |         |         |
      Q2(UL)    Q4(VL)    Q6(WL)   <-- 下臂开关管
        |         |         |
        +----+----+----+----+
             |
          GND (电源负极)
```
 b. 理想开关情况

在理想情况下，为了控制电机绕组的电流，我们希望**同一相的上臂和下臂开关管永远不要同时导通**。因为如果它们同时导通，就相当于将电源正极（+DC Bus）直接短路到电源负极。这会产生一个巨大的电流，被称为“直通”或“ Shoot-Through”。
- **正常工作**：例如U相，Q1导通时，Q2必须关断；Q2导通时，Q1必须关断。这样电流才能从电源流经电机绕组，或者通过下臂续流。

 c. 现实中的问题：开关延迟

现实中的开关管不是理想的。它们从接收到“关断”信号到真正完全断开，需要一小段时间，称为**关断延迟**。同样，从接收到“导通”信号到完全导通，也需要**导通延迟**。通常，关断延迟会比导通延迟长。
现在，考虑一下微控制器输出的互补PWM信号：
- MCU给Q1一个“关断”信号。
- **同时**，MCU给Q2一个“导通”信号。
由于Q1的关断延迟，它还没有完全断开。而Q2收到导通信号后，经过它的导通延迟，开始导通。在这一瞬间，Q1和Q2可能都处于半导通状态，导致了**短暂的直通**！
这个瞬间的短路电流虽然时间很短，但峰值极高，会导致：
- **开关管损坏**：巨大的电流和功率会瞬间烧毁昂贵的MOSFET。
- **效率降低**：直通会产生额外的热量，属于纯粹的功率损耗。
- **电磁干扰**：电流的剧烈突变会产生严重的EMI，干扰系统其他部分。
- **电源电压跌落**：巨大的电流会引起电源电压瞬间跌落，可能影响MCU或其他电路的正常工作。
---
2. 解决方案：死区时间

为了解决上述问题，我们在驱动信号中人为地插入一小段“什么都不做”的时间，这就是**死区时间**。

 工作原理：

当需要切换开关状态时（例如，从上臂导通切换到下臂导通）：
1. MCU首先发送“关断”信号给当前导通的开关管（例如Q1）。
2. **等待一小段时间（死区时间）**。在这段时间里，Q1和Q2的驱动信号都是关断状态。
3. 确保Q1已经**完全关断**后，再发送“导通”信号给另一个开关管（Q2）。
这样就从根本上避免了上下臂同时导通的风险。
```
理想互补PWM (无死区):
  Q1 (上臂):  ________         ________
             |        |       |
             |        |       |
  Q2 (下臂):          |_______|         _______
                                |       |
                                |_______|
实际带死区的PWM:
  Q1 (上臂):  ________         ________
             |        |       |
             |        |       |
  Q2 (下臂):     |_______|         |_______|
             DT|       |       DT|       |
               |_______|         |_______|
               <--死区时间-->     <--死区时间-->
```
---
3. 死区时间对驱动直流无刷电机的具体好处

基于以上原理，设置死区时间带来了以下关键好处：

好处一：**防止功率器件损坏（最重要的好处）**

这是死区时间存在的首要原因。它通过物理上确保了“先断后通”，彻底消除了桥臂直通的风险，从而保护了电路中最昂贵也最脆弱的功率开关管，大大提高了系统的**可靠性**。

好处二：**提高系统效率**

虽然死区时间本身会带来一些微小的负面效应（见下文），但它避免了直通短路造成的巨大功率损耗。直通损耗是“硬开关”损耗，远大于死区期间造成的效率损失。因此，**合理设置死区时间是提升整体系统效率的关键**。

好处三：**减少电磁干扰**

直通时巨大的电流变化率会产生强烈的电磁噪声。通过消除直通，系统的EMI性能得到显著改善，使得整个设备更容易通过电磁兼容性测试，并且不会干扰自身的控制电路。

好处四：**稳定电源总线**

避免了因直通引起的电源电压瞬时跌落，保证了MCU和传感器等敏感部件的供电稳定，使控制系统更加**可靠**。

4. 死区时间的代价与权衡（需要注意的负面影响）

死区时间并非完美无缺，它是一把双刃剑。它是以牺牲一部分“理想控制”为代价来换取安全的。

主要负面影响：**波形失真和转矩脉动**

在死区期间，上下臂开关管都是关断的。此时，电机绕组的电流无法通过主动的开关管流向电源或地，只能通过开关管**并联的续流二极管**进行续流。
- **续流过程**：电流会根据其方向，自然地通过上臂或下臂的二极管流向DC总线或地。
- **等效效果**：这个续流过程相当于在输出端上产生了一个与电流方向相关的、非受控的电压。这个电压的持续时间就是死区时间。
**结果：**
- 实际施加在电机绕组上的电压波形，与MCU理想输出的PWM波形相比，产生了**失真**。
- 这个电压失真会导致输出电流的波形也产生失真，特别是当电流过零点时，失真最为明显。
- 电流的失真会转化为电机输出**转矩的脉动**。你可能会感觉到电机在低速运行时不够平滑，有轻微的抖动或噪音。

如何权衡？

死区时间的选择是一个**工程上的权衡**：
- **死区时间太长**：保护效果好，但波形失真严重，转矩脉动大，电机控制性能差，尤其是在低速时。
- **死区时间太短**：波形失真小，控制性能好，但可能无法完全覆盖开关管的延迟，存在直通风险，系统不安全。
**最佳实践：**
1.  **查阅数据手册**：首先查看你所使用的MOSFET/IGBT的数据手册，找到其“关断延迟时间”和“导通延迟时间”。
2.  **留出余量**：死区时间应大于最坏情况下的关断延迟与导通延迟之差，并留出一定的安全余量。通常，几百纳秒到几微秒是比较常见的范围。
3.  **实验调整**：在保证安全的前提下，尽量使用**最小的、可靠**的死区时间，以最大化控制性能。很多先进的电机驱动算法（如FOC）甚至会包含**死区补偿算法**，通过软件来主动修正死区时间引起的电压误差，从而消除其负面影响。

总结

| 特性                                                         | 无死区时间               | 有死区时间                 |
| :----------------------------------------------------------- | :----------------------- | :------------------------- |
| **安全性**                                                   | **极低**，极易烧毁功率管 | **高**，有效防止直通       |
| **效率**                                                     | **低**，直通损耗巨大     | **高**，避免了主要损耗源   |
| **EMI**                                                      | **严重**，电流尖峰干扰大 | **良好**，开关过程更平滑   |
| **控制性能**                                                 | 理论上完美（但无法实现） | **有失真**，会导致转矩脉动 |
| **系统稳定性**                                               | 差，电源易受干扰         | 好，系统工作可靠           |
| **结论：** 为直流无刷电机驱动设置PWM死区时间，是**用微小的、可控的性能牺牲，换取了整个系统的安全、稳定和高效率**。它是任何严肃的电机驱动设计中不可或缺的一环。 |                          |                            |

#### 代码库

```c
	TIM_BDTRInitTypeDef TIM_BDTRInitStruct;
	TIM_BDTRStructInit(&TIM_BDTRInitStruct);
	TIM_BDTRInitStruct.TIM_DeadTime=PWM_DeadTime;
	TIM_BDTRInitStruct.TIM_AutomaticOutput=TIM_AutomaticOutput_Disable;
	TIM_BDTRInitStruct.TIM_Break=TIM_Break_Disable;
	TIM_BDTRInitStruct.TIM_LOCKLevel=TIM_LOCKLevel_OFF;
	TIM_BDTRInitStruct.TIM_OSSRState=TIM_OSSRState_Enable;
	TIM_BDTRInitStruct.TIM_OSSIState=TIM_OSSRState_Enable;
	TIM_BDTRConfig(TIM_USE,&TIM_BDTRInitStruct);
```

标准库为我们提供了死区的应用层代码，其中TIM_DeadTime成员即是管理死区时间的参数，我们需要打开TIM_OSSRState和TIM_OSSIState，其他的关闭即可，其他的暂时用不到，有兴趣可以查。

TIM_DeadTime为0x24时大概时间为500ns的死区时间

## PWMI

### 输入捕获

### 简介

> •IC（Input Capture）输入捕获
>
> •输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数
>
> •每个高级定时器和通用定时器都拥有4个输入捕获通道
>
> •可配置为PWMI[^PWMI]模式，同时测量频率和占空比
>
> 可配合主从触发模式，实现硬件全自动测量

PWMI的本质就是获取CNT的值。

[^PWMI]: PWM的输入模式

### 频率测量

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1192109.png)

> 越往左频率越高，越往右频率越低
>
> 频率的定义：1s内出现了多少个重复的周期，频率等于多少Hz

> 测频法适合测量高频信号
>
> 测周法适合测量低频信号
>
> 正负1误差是测量的固有误差，在测频法中，有可能因为T时间内周期最后走了一半，所以只能取整1或者舍弃最后的1. 在测周法中，固有频率fm也有可能多走了半个，只能舍弃或者取整，所以只能多测几次。
>
> 中界频率：f

### 结构图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1201043.png)

> TI1: 输入通道
>
> f~DTS~:滤波器的采样时钟源
>
> CCMR1寄存器的ICF位:控制滤波器的参数
>
> 边沿检测器：可以捕获上升沿还是下降沿
>
> CCP1：选择极性
>
> CC1S位可以对数据选择器进行选择
>
> 1CPS位可以配置分频器
>
> CC1E：控制输出使能或失能
>
> 从模式控制器：可以自动将CNT清0

滤波器原理：对输入的波形进行采样，连续N个值为低电平才输出低电平，则高频抖动导致连续采样的值不一样，则会将其滤掉

### 主从触发模式

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1201057.png)

主模式：将定时器内部的信号映射到TRGO引脚，用于触发别的外设

从模式：接受其他外设或者自身外设的一些信号，用于控制自身定时器的运行。从模式可以在右列表里选择一项操作自动执行

触发源选择：选择从模式的触发信号源，选择指定的一个信号，得到TRGI，TRGI去触发从模式

#### CNT自动清零

触发源选择TI2FP1，从模式选择Reset.

TI1FP1的信号可以自动触发从模式，从模式自动清0

### 输入捕获基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/12001106.png)

### PWMI基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1201108.png)



> PWMI：CCR1是整个周期的时间，CCR2是高电平的时间，则CCR2/CCR1则是PWM的占空比

### 步骤

根据PWMI的基本结构图

* RCC开启时钟，将GPIO和TIM的时钟打开
* GPIO初始化，将GPIO配置成输入模式
* 配置时基单元，让CNT计数器在内部时钟的驱动下自增运行
* 配置输入捕获单元（滤波器、极性、直连通道or交叉通道、分频器等）
* 选择从模式的触发源（用TI1FP1）、调用一个函数，给一个参数即可
* 选择触发之后执行的操作（Resat）
* 调用TIM_Cmd函数，开启定时器

### 代码

#### 函数库

``` c
/*单独改变psc值的函数，从而改变pwm的频率*/
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);

/*配置输入捕获单元的函数*/
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);  //单一的配置一个通道
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);//快速的配置第二个通道

/*给输入捕获结构体赋予一个初始值*/
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);

/*选择输入触发源*/
void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);

/*选择输出触发源*/
void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);

/*选择从模式*/
void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);

/*单独配置通道1、2、3、4的分频器*/
void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);

/*分别读取四个通道的CCR*/
uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);
uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);
uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);
uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);
```

#### 环境的配置

``` c
void IC_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			//开启TIM3的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);							//将PA6引脚初始化为上拉输入
	
	/*配置时钟源*/
	TIM_InternalClockConfig(TIM3);		//选择TIM3为内部时钟，若不调用此函数，TIM默认也为内部时钟
	
	/*时基单元初始化*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				//定义结构体变量
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;               //计数周期，即ARR的值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;               //预分频器，即PSC的值
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);             //将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元
	
	/*输入捕获初始化*/
	TIM_ICInitTypeDef TIM_ICInitStructure;							//定义结构体变量
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				//选择配置定时器通道1
	TIM_ICInitStructure.TIM_ICFilter = 0xF;							//输入滤波器参数，可以过滤信号抖动
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		//极性，选择为上升沿触发捕获
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//捕获预分频，选择不分频，每次信号都触发捕获
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;	//输入信号交叉，选择直通，不交叉
	TIM_ICInit(TIM3, &TIM_ICInitStructure);							//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道
	
	/*选择触发源及从模式*/
	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);					//触发源选择TI1FP1
	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);					//从模式选择复位
																	//即TI1产生上升沿时，会触发CNT归零
	
	/*TIM使能*/
	TIM_Cmd(TIM3, ENABLE);			//使能TIM3，定时器开始运行
}
```

#### 运行

```c
/**
  * 函    数：获取输入捕获的频率
  * 参    数：无
  * 返 回 值：捕获得到的频率
  */
uint32_t IC_GetFreq(void)
{
	return 1000000 / (TIM_GetCapture1(TIM3) + 1);		//测周法得到频率fx = fc / N，这里不执行+1的操作也可
}
```

## 编码器接口

### 简介

> •Encoder Interface 编码器接口
>
> •编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度
>
> •每个高级定时器和通用定时器都拥有1个编码器接口
>
> •两个输入引脚借用了输入捕获的通道1和通道2

> CH3和CH4不能用做编码器接口

### 正交编码器

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/125956.png)

### 基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251003.png)

### 工作模式

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251005.png)

### 实例

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251009.png) 

#### TI1反相

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251013.png)

> 当我们想要的数据与实际的操作相反时，既可以改变极性选择的值，使其反向输出。

### 程序

#### 步骤

* RCC开启时钟，开启GIPO和定时器的时钟
* 配置GPIO，将PA口配置成输入模式（哪个口根据你所要用的通道和引脚定义查看）
* 配置时基单元，预分频器选择不分频、自动重装一般给最大65535
* 配置输入捕获单元
* 配置编码器接口模式
* 启动定时器

#### 库函数

```c
/*定时器编码器接口配置*/
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode, uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
```



#### 环境配置

```c
void Encoder_Init(void)
{
	/*开启时钟*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			//开启TIM3的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);							//将PA6和PA7引脚初始化为上拉输入
	
	/*时基单元初始化*/
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				//定义结构体变量
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数
	TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;               //计数周期，即ARR的值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;                //预分频器，即PSC的值
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);             //将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元
	
	/*输入捕获初始化*/
	TIM_ICInitTypeDef TIM_ICInitStructure;							//定义结构体变量
	TIM_ICStructInit(&TIM_ICInitStructure);							//结构体初始化，若结构体没有完整赋值
																	//则最好执行此函数，给结构体所有成员都赋一																	    个默认值
																	//避免结构体初值不确定的问题
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				//选择配置定时器通道1
	TIM_ICInitStructure.TIM_ICFilter = 0xF;							//输入滤波器参数，可以过滤信号抖动
	TIM_ICInit(TIM3, &TIM_ICInitStructure);							//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;				//选择配置定时器通道2
	TIM_ICInitStructure.TIM_ICFilter = 0xF;							//输入滤波器参数，可以过滤信号抖动
	TIM_ICInit(TIM3, &TIM_ICInitStructure);							//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道
	
	/*编码器接口配置*/
	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
																	//配置编码器模式以及两个输入通道是否反相
																	//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相
																	//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置
	
	/*TIM使能*/
	TIM_Cmd(TIM3, ENABLE);			//使能TIM3，定时器开始运行
}
```

 

#### 运行

```c
/**
  * 函    数：获取编码器的增量值
  * 参    数：无
  * 返 回 值：自上此调用此函数后，编码器的增量值
  */
int16_t Encoder_Get(void)
{
	/*使用Temp变量作为中继，目的是返回CNT后将其清零*/
	int16_t Temp;
	Temp = TIM_GetCounter(TIM3);
	TIM_SetCounter(TIM3, 0);
	return Temp;
}
```



# ADC数模转换器

## ADC简介

•ADC（Analog-Digital Converter）模拟-数字转换器

•ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁

•12位逐次逼近型ADC，1us转换时间

•输入电压范围：0-3.3V，转换结果范围：0-4095

•18个输入通道，可测量16个外部和2个内部信号源

•规则组和注入组两个转换单元

•模拟看门狗自动监测输入电压范围

•STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道

ADC多通道的转换地只能存一个数据，虽然是多通道，但是会覆盖。所以要配合DMA使用。

> ADC两个关键参数：分辨率和转换频率
>
> 12位AD值表示范围是：0~2^12^-1、量化结果的范围是0-4095。位数越高，量化结果越精细，对应的分辨率就越高
>
> 1us->AD转换的频率就是1MHz。

分辨率：

> 指ADC能分辨的最小电压，反应了ADC对输入模拟量微小变化的分辨能力。当最大输入电压一定时，位数越多，量化单位越小，误差越小，分辨率越高。
>
> eg:一个十二位ADC，参考电压为3.3V，能分辨的最小电压为：3.3V/2^12=0.8mV

转换时间：

> 指ADC从控制信号到来开始，到输出端得到稳定的数字信号所经历的时间

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115105248.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115105450.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20260115105408.png)

## 逐次逼近型ADC

### 内部结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251427.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251439.png)

![1251447](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251447.png)

### 输入通道

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251449.png)

## 规则组的四种转换模式

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251454.png)

该模式只有序列1位置有效，如果想再次转换，则需要再次触发

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251455.png)

对该位置持续转换，不需要手动转换

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251456.png)

下次转换必须要再触发才能开始，而且可以选择通道数目。

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251457.png)

## 触发控制

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251501.png)

## 数据对齐

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251502.png)

数据左对齐一般用于减少精度，只取前面8位

## 转换时间

AD转换的步骤：采样，保持，量化，编码

•STM32 ADC的总转换时间为：

 TCONV = 采样时间 + 12.5个ADC周期



>  •例如：当ADCCLK=14MHz，采样时间为1.5个ADC周期
>
> ​    TCONV = 1.5 + 12.5 = 14个ADC周期 = 1μs

### 校准

•ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差

•建议在每次上电后执行一次校准

•启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期

## 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1251509.png)

## 程序

### 步骤

* 开启RCC时钟，包括GPIOA和ADC时钟，还有ADCCLK时钟线
* 配置GPIO环境，配置成模拟输入模式
* 利用ADC_RegularChannelConfig函数配置好注入组通道
* 利用ADC_Init函数配置好ADC
* 调用ADC_Cmd函数开启ADC
* ADC校准
    * ADC_ResetCalibration()
    * ADC_GetResetCalibrationStatus()
    * ADC_StartCalibration()
    * ADC_GetCalibrationStatus()

* 如果需要模拟开门狗和中断需要额外配置，根据手册。

### 库函数

ADC的时钟线是在RCC中的

```c
/*打开ADC时钟线*/
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);  //记得选择6分频

/*ADC初始化*/
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);

/*结构体初始化*/
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);

/*给ADC上电*/
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);

/*开启DMA输出信号函数*/
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);

/*中断输出控制*/
void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);

/*复位校准*/
void ADC_ResetCalibration(ADC_TypeDef* ADCx);

/*获取复位标准状态*/
FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);

/*开始校准*/
void ADC_StartCalibration(ADC_TypeDef* ADCx);

/*获取开始校准状态*/
FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);

/*软件触发ADC转换*/
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);

/*ADC获取软件开始转换状态*/
FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);

/*获取标志位状态*/
FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);//可以知道转换是否结束

/*配置间断模式*/
void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);//每隔几个通道间断一次
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState); //是不是启用间断模式

/*ADC规则组通道配置*/
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);

/*ADC外部触发转换控制，是否允许外部触发转换*/
void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);

/*ADC获取转换值*/
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);

/*对ADC注入组进行配置*/
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);

/*是否启动模拟看门狗*/
void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);

/*配置高低阈值*/
void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);

/*配置看门狗通道*/
void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);

/*开启内部的两个通道*/
void ADC_TempSensorVrefintCmd(FunctionalState NewState);

/*获取标志位状态，其中包括EOC转换完成的标志位*/
FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);

/*清除标志位*/
void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);

/*获取中断状态*/
ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);

/*清除中断挂起位*/
void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);

```

### 环境配置

```c
void AD_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	//开启ADC1的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//开启GPIOA的时钟
	
	/*设置ADC时钟*/
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);						//选择时钟6分频，ADCCLK = 72MHz / 6 = 12MHz
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);					//将PA0引脚初始化为模拟输入
	
	/*规则组通道配置*/
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);		//规则组序列1的位置，配置为通道0
	
	/*ADC初始化*/
	ADC_InitTypeDef ADC_InitStructure;						//定义结构体变量
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;		//模式，选择独立模式，即单独使用ADC1
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	//数据对齐，选择右对齐
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//外部触发，使用软件触发，不需要外部触发
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		//连续转换，失能，每转换一次规则组序列后停止
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;			//扫描模式，失能，只转换规则组的序列1这一个位置
	ADC_InitStructure.ADC_NbrOfChannel = 1;					//通道数，为1，仅在扫描模式下，才需要指定大于1的数，在非扫描模式下，只能是1
	ADC_Init(ADC1, &ADC_InitStructure);						//将结构体变量交给ADC_Init，配置ADC1
	
	/*ADC使能*/
	ADC_Cmd(ADC1, ENABLE);									//使能ADC1，ADC开始运行
	
	/*ADC校准*/
	ADC_ResetCalibration(ADC1);								//固定流程，内部有电路会自动执行校准
	while (ADC_GetResetCalibrationStatus(ADC1) == SET);  //SET是正在校准，所以要等待，z
	ADC_StartCalibration(ADC1);
	while (ADC_GetCalibrationStatus(ADC1) == SET);
}
```



### 运行

* 软件触发
* 等待EOC标志位
* 获取寄存器数据

```c
uint16_t AD_GetValue(void)
{
	ADC_SoftwareStartConvCmd(ADC1, ENABLE);					//软件触发AD转换一次
	while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);	//等待EOC标志位，即等待AD转换结束
	return ADC_GetConversionValue(ADC1);					//读数据寄存器，得到AD转换的结果
}
```

## 理解

ADC其实是一个内部，将一个引脚的电平信号转换成电压信号，然后通过一个函数得出转换后的值。

ADC的软件触发是靠一个函数，执行到函数时则开始转换。

# DMA

## 简介

•DMA（Direct Memory Access）直接存储器存取

•DMA可以提供外设和存储器[^存储器]或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源

•12个独立可配置的通道： DMA1（7个通道[^通道]）， DMA2（5个通道）

•每个通道都支持软件触发和特定的硬件触发

•STM32F103C8T6 DMA资源：DMA1（7个通道）

> 存储器和存储器之间的转运经常用到软件触发，可以一下子全部传过去
>
> 外设和存储器之间的转运经常用到硬件触发，因为外设的数据是有一定时机的
>
> 每个DMA的通道，硬件触发源不一样

[^存储器]:运行内存SRAM和程序储存器Flash
[^通道]:数据的转运是需要通道的



### 存储器映像

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261016.png)

计算机系统的五大组成部分：运算器、控制器、存储器、输入设备、输出设备

ROM：只读存储器，是一种非易失性，掉电不丢失的存储器

RAM：随机存储器，是一种易失性，掉电不保存的存储器



## DMA框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261029.png)

## DMA基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261036.png)

>  地址是否自增：是否转运完后要转运地址的下一个位置
>
> 传输计数器：是一个自减计数器，指的是要转运几次
>
> 自动重装器：自减完是否要回到初始值
>
> M2M：决定是软件触发还是硬件触发。M2M=1,执行软件触发。M2M=0，执行硬件触发。
>
> 软件触发：以最快的速度，连续不断地触发DMA。 注意：软件触发和自动重装器不能同时使用
>
> 写入传输计数器必须先关闭DMA后再开启

DMA转运的条件：

* 开关控制，DMA_Cmd使能
* 传输计数器必须大于0
* 必须有触发源

## DMA请求

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261054.png)

EN位：数据选择器使能位，给1则工作，给0则不工作

外设对应通道：对应的外设有决定是否开启DMA的函数，例如ADC1则有ADC_DMACmd函数来开启DMA通道

## 数据宽度和对齐

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261101.png)

关于两端的数据宽度不一样

如果实际小于填写的宽度，则会在数据前面补0/高位补0

如果实际大于填写的宽度，把多于的高位去掉

## 实际运用

### 数据转运+DMA

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261106.png)



### ADC扫描模式+MDA

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261107.png)

运行流程：DMA配置从外设地址转运到DMA存储地址，此时外设地址不自增，存储器地址自增。当单个通道转换完成会想DMA发送请求，所以此时是硬件触发。连续扫描模式+自动重装器可以实行自动化

## 程序

### 步骤

* 打开DMA1的时钟，在AHB总线中
* DMA结构体赋值和DMA定义函数

### 函数库

```c
/*初始化*/
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);

/*结构体初始化*/
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);

/*DMA使能*/
void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);

/*中断输出使能*/
void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);

/*设置当前寄存器，即给传输计数器写值的函数*/
void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber); 

/*返回传输计数器的值*/
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);

/*获取标志位状态*/
FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);

/*清除标志位*/
void DMA_ClearFlag(uint32_t DMAy_FLAG);

/*获取中断标志位*/
ITStatus DMA_GetITStatus(uint32_t DMAy_IT);

/*清除中断标志位*/
void DMA_ClearITPendingBit(uint32_t DMAy_IT);
```

### 数组间传输环境的配置

```c
void MyDMA_Init(uint32_t AddrA, uint32_t AddrB, uint16_t Size)
{
	MyDMA_Size = Size;					//将Size写入到全局变量，记住参数Size
	
	/*开启时钟*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);						//开启DMA的时钟
	
	/*DMA初始化*/
	DMA_InitTypeDef DMA_InitStructure;										//定义结构体变量
	DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;						//外设基地址，给定形参AddrA
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	//外设数据宽度，选择字节
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;			//外设地址自增，选择使能
	DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;							//存储器基地址，给定形参AddrB
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;			//存储器数据宽度，选择字节
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;					//存储器地址自增，选择使能
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;						//数据传输方向，选择由外设到存储器
	DMA_InitStructure.DMA_BufferSize = Size;								//转运的数据大小（转运次数）
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;							//模式，选择正常模式
	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;								//存储器到存储器，选择使能
	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;					//优先级，选择中等
	DMA_Init(DMA1_Channel1, &DMA_InitStructure);							//将结构体变量交给DMA_Init，配置DMA1的通道1
	
	/*DMA使能*/
	DMA_Cmd(DMA1_Channel1, DISABLE);	//这里先不给使能，初始化后不会立刻工作，等后续调用Transfer后，再开始
}
```

### 数组间传输间运行

```c
void MyDMA_Transfer(void)
{
	DMA_Cmd(DMA1_Channel1, DISABLE);					//DMA失能，在写入传输计数器之前，需要DMA暂停工作
	DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);	//写入传输计数器，指定将要转运的次数
	DMA_Cmd(DMA1_Channel1, ENABLE);						//DMA使能，开始工作
	
	while (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);	//等待DMA工作完成
	DMA_ClearFlag(DMA1_FLAG_TC1);						//清除工作完成标志位
}
```

### ADC+DMA环境配置

```c
void AD_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);	//开启ADC1的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//开启GPIOA的时钟
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		//开启DMA1的时钟
	
	/*设置ADC时钟*/
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);						//选择时钟6分频，ADCCLK = 72MHz / 6 = 12MHz
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);					//将PA0、PA1、PA2和PA3引脚初始化为模拟输入
	
	/*规则组通道配置*/
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);	//规则组序列1的位置，配置为通道0
	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5);	//规则组序列2的位置，配置为通道1
	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5);	//规则组序列3的位置，配置为通道2
	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5);	//规则组序列4的位置，配置为通道3
	
	/*ADC初始化*/
	ADC_InitTypeDef ADC_InitStructure;											//定义结构体变量
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;							//模式，选择独立模式，即单独使用ADC1
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;						//数据对齐，选择右对齐
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;			//外部触发，使用软件触发，不需要外部触发
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;							//连续转换，使能，每转换一次规则组序列后立刻开始下一次转换
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;								//扫描模式，使能，扫描规则组的序列，扫描数量由ADC_NbrOfChannel确定
	ADC_InitStructure.ADC_NbrOfChannel = 4;										//通道数，为4，扫描规则组的前4个通道
	ADC_Init(ADC1, &ADC_InitStructure);											//将结构体变量交给ADC_Init，配置ADC1
	
	/*DMA初始化*/
	DMA_InitTypeDef DMA_InitStructure;											//定义结构体变量
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;				//外设基地址，给定形参AddrA
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	//外设数据宽度，选择半字，对应16为的ADC数据寄存器
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;			//外设地址自增，选择失能，始终以ADC数据寄存器为源
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)AD_Value;					//存储器基地址，给定存放AD转换结果的全局数组AD_Value
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;			//存储器数据宽度，选择半字，与源数据宽度对应
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;						//存储器地址自增，选择使能，每次转运后，数组移到下一个位置
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;							//数据传输方向，选择由外设到存储器，ADC数据寄存器转到数组
	DMA_InitStructure.DMA_BufferSize = 4;										//转运的数据大小（转运次数），与ADC通道数一致
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;								//模式，选择循环模式，与ADC的连续转换一致
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;								//存储器到存储器，选择失能，数据由ADC外设触发转运到存储器
	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;						//优先级，选择中等
	DMA_Init(DMA1_Channel1, &DMA_InitStructure);								//将结构体变量交给DMA_Init，配置DMA1的通道1
	
	/*DMA和ADC使能*/
	DMA_Cmd(DMA1_Channel1, ENABLE);							//DMA1的通道1使能
	ADC_DMACmd(ADC1, ENABLE);								//ADC1触发DMA1的信号使能
	ADC_Cmd(ADC1, ENABLE);									//ADC1使能
	
	/*ADC校准*/
	ADC_ResetCalibration(ADC1);								//固定流程，内部有电路会自动执行校准
	while (ADC_GetResetCalibrationStatus(ADC1) == SET);
	ADC_StartCalibration(ADC1);
	while (ADC_GetCalibrationStatus(ADC1) == SET);
	
	/*ADC触发*/
	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	//软件触发ADC开始工作，由于ADC处于连续转换模式，故触发一次后ADC就可以一直连续不断地工作
}

```

# 通信协议

## 简介

•通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统

•通信协议：制定通信的规则，通信双方按照协议规则进行数据收发

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261514.png)

引脚

> TX：数据发送脚
>
> RX：数据接收脚
>
> SCL：时钟线
>
> SDA：数据
>
> SCLK：时钟线
>
> MOSI：主机输出数据脚
>
> MISO：主机输入数据脚
>
> CS：片选，指定通信对象
>
> CAN_H and CAN_L : 差分数据脚
>
> DP and DM or D+ and D- : 差分数据脚

双工模式：

> 全双工：双方能够同时进行双向通信（有两根通信线）
>
> 半双工：双方同一时间只能由一方通向一方
>
> 单工：数据只能一个设备到另一个设备，不能反着来

时钟特性

> 同步：因为时钟线的存在，所以可以在时钟信号的指引下进行采样
>
> 异步：双方约定一个频率，还需要加帧头帧尾等进行采样的对齐

电平特性

> 单端：引脚的高低电平都是对GND的电压差，所以通信双方必须要共地，GND要接在一起，有一个标准的电压标准
>
> 差分：靠差分引脚的电压差来传输信号，可以不需要GND，抗干扰能力很强

设备特性

> 点对点：单个设备进行通信
>
> 多设备：可以在总线上挂载多个设备

## 串口通信

#### 简介

•串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信

•单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力

### 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261531.png)

### 电压标准

•电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：

•TTL电平：+3.3V或+5V表示1，0V表示0

•RS232电平：-3 ~ -15V表示1，+3~+15V表示0

•RS485电平：两线压差+2 ~ +6V表示1，-2 ~ -6V表示0（差分信号）

### 串口参数及时序

•波特率：串口通信的速率  约定时间发送和接收

•起始位：标志一个数据帧的开始，固定为低电平

•数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行

•校验位：用于数据验证，根据数据位计算得来

•停止位：用于数据帧间隔，固定为高电平

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261537.png)

引脚空闲状态一定要高电平，这样子起始位低电平才有效

校验位：无校验，奇校验，偶校验

校验：奇校验，如果8位数据有偶数个1，则校验位置1使1达到奇数个，如果数据有奇数个1，则校验位置0。偶校验则相反。

缺点：抗扰性不强，如果改写了两个数据就没办法校验了。

### 串口时序

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261557.png)

起始位就是前面的低电平默认不是数据，停止位就是最后一位高电平默认不是数据

## USART

### 简介

•USART（Universal Synchronous/Asynchronous Receiver/Transmitter）通用同步/异步收发器

•USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里

•自带波特率发生器，最高达4.5Mbits/s

•可配置数据位长度（8/9）、停止位长度（0.5/1/1.5/2）

•可选校验位（无校验/奇校验/偶校验）

•支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN

STM32F103C8T6 USART资源： USART1、 USART2、 USART3

硬件流控制：多出一根数据线来使发送数据端知道接收端是否准备好了



### 框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261409.png)

> 当数据从TDR移动到移位寄存器时，会置一个标志位，叫TXE。TXE如果置1，说明已经移走了，可以在TDR写入下一个数据
>
> 当接收移位寄存器的数据移动到接受数据寄存器，也会置一个标志位，叫RXNE，如果置1，则说明数据已经被读走了。
>
> nCTS：接受端,n代表低电平有效，当CTS置1时说明接收端处理不过来，让发送端停止发送。
>
> nRTS：发送端。用来接受CTS的电平。
>
> 唤醒单元：用来挂载多串口通信设备用的

### 简化结构图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1261626.png)

移位寄存器是右移，低位先行。

### 数据帧

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/127949.png)

注意：LBCL是控制最后一个数据的时钟脉冲，也就是校验位的时钟是由它控制的

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/127952.png)

#### 起始位侦测

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/127959.png)

中间采样如果出现了一位1，即出现了噪音，但是数据还是能传进来， 不过会置一个NE标志位告诉你有噪音干扰.

数据中间和采样的对齐也是在起始位完成的。

#### 数据采样

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1271000.png).

采样实在数据的8、9、10位置中进行连续采样。如果在数据中受到噪音的干扰，则采用2：1的法则。收到2个1，一个0则认为收到了1，在这种情况下，噪声的NE状态位也会置1.

#### 波特率发生器

•发送器和接收器的波特率由波特率寄存器BRR里的DIV确定

•计算公式：波特率 = f~PCLK2/1~ / (16 * DIV)    //16是一位数据采样16次

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1271004.png)

BRR寄存器就是用来配置波特比率。

[11:0]是整数部分，[3:0]是小数部分

例如配置9600的波特率： 9600=72M/(16*DIV)			DIV=468.75

因为寄存器是以二进制形式储存的，所以DIV转换为二进制为：111010100.11(整数高位补零，小数低位补零)

### 数据包

#### HEX数据包

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1272042.png)

适用于数据的传输，像陀螺仪的数据和温度传感器的数据

#### 文本数据包

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1272050.png)

文本数据包与HEX数据包不同的地方在于文本数据包每一个数据都经过了一层编码和译码

适用于人机交互的领域

#### 数据包的收发流程

##### HEX数据包接收

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1272055.png)

##### 文本数据包接收

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1272056.png)

因为文本数据包是长度不定的，所以每次都要判断一下是不是'\r'

### 数据模式

•HEX模式/十六进制模式/二进制模式：以原始数据的形式显示

•文本模式/字符模式：以原始数据编码后的形式显示

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1271048.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1271049.png)

### 单字节程序

#### 函数库

```c
/*函数的定义*/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);

/*结构体赋初始值*/
void USART_StructInit(USART_InitTypeDef* USART_InitStruct);

/*配置同步时钟输出*/
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);

/*使能打开USART*/
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);

/*中断输出使能*/
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);

/*开启USART到DMA的触发通道*/
void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);

/*发送数据*/
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);

/*接收数据*/
uint16_t USART_ReceiveData(USART_TypeDef* USARTx);

/*获取发送标志位状态*/
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);

/*清除标志位状态*/
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);//USART是自动清除标志位，所以比较少用这个函数

/*获取中断标志位状态*/
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);

/*清除中断标志位状态*/
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
```



#### 输出配置步骤

* 开启时钟，打开USART和GPIO的时钟
* GPIO初始化，把TX配置成复用输出，RX配置成输入
* 配置USART，直接使用Init()函数
* 开启USART



#### 环境配置

```c
void Serial_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//开启USART1的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);					//将PA9引脚初始化为复用推挽输出
	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);					//将PA10引脚初始化为上拉输入
	
	/*USART初始化*/
	USART_InitTypeDef USART_InitStructure;					//定义结构体变量
	USART_InitStructure.USART_BaudRate = 9600;				//波特率
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//硬件流控制，不需要
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;	//模式，发送模式和接收模式均选择
	USART_InitStructure.USART_Parity = USART_Parity_No;		//奇偶校验，不需要
	USART_InitStructure.USART_StopBits = USART_StopBits_1;	//停止位，选择1位
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//字长，选择8位
	USART_Init(USART1, &USART_InitStructure);				//将结构体变量交给USART_Init，配置USART1
	
	/*中断输出配置*/
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);			//开启串口接收数据的中断
	
	/*NVIC中断分组*/
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);			//配置NVIC为分组2
	
	/*NVIC配置*/
	NVIC_InitTypeDef NVIC_InitStructure;					//定义结构体变量
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;		//选择配置NVIC的USART1线
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//指定NVIC线路使能
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;		//指定NVIC线路的抢占优先级为1
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		//指定NVIC线路的响应优先级为1
	NVIC_Init(&NVIC_InitStructure);							//将结构体变量交给NVIC_Init，配置NVIC外设
	
	/*USART使能*/
	USART_Cmd(USART1, ENABLE);								//使能USART1，串口开始运行
}
```

#### 发送函数

```c
/**
  * 函    数：串口发送一个字节
  * 参    数：Byte 要发送的一个字节
  * 返 回 值：无
  */
void Serial_SendByte(uint8_t Byte)
{
	USART_SendData(USART1, Byte);		//将字节数据写入数据寄存器，写入后USART自动生成时序波形
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);	//等待发送完成
	/*下次写入数据寄存器会自动清除发送完成标志位，故此循环后，无需清除标志位*/
}

/**
  * 函    数：串口发送一个数组
  * 参    数：Array 要发送数组的首地址
  * 参    数：Length 要发送数组的长度
  * 返 回 值：无
  */
void Serial_SendArray(uint8_t *Array, uint16_t Length)
{
	uint16_t i;
	for (i = 0; i < Length; i ++)		//遍历数组
	{
		Serial_SendByte(Array[i]);		//依次调用Serial_SendByte发送每个字节数据
	}
}

/**
  * 函    数：串口发送一个字符串
  * 参    数：String 要发送字符串的首地址
  * 返 回 值：无
  */
void Serial_SendString(char *String)
{
	uint8_t i;
	for (i = 0; String[i] != '\0'; i ++)//遍历字符数组（字符串），遇到字符串结束标志位后停止
	{
		Serial_SendByte(String[i]);		//依次调用Serial_SendByte发送每个字节数据
	}
}
/**
  * 函    数：USART1中断函数
  * 参    数：无
  * 返 回 值：无
  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行
  *           函数名为预留的指定名称，可以从启动文件复制
  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入
  *	思想：利用中断，如果有数据进来触发了中断，则判断是否是USART1触发的，然后直接读取数据然后置接收标志位，清除中断标志位
  */
void USART1_IRQHandler(void)
{
	if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)		//判断是否是USART1的接收事件触发的中断
	{
		Serial_RxData = USART_ReceiveData(USART1);				//读取数据寄存器，存放在接收的数据变量
		Serial_RxFlag = 1;										//置接收标志位变量为1
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);			//清除USART1的RXNE标志位
																//读取数据寄存器会自动清除此标志位
																//如果已经读取了数据寄存器，也可以不执行此代码
	}
}

/**
  * 函    数：获取串口接收标志位
  * 参    数：无
  * 返 回 值：串口接收标志位，范围：0~1，接收到数据后，标志位置1，读取后标志位自动清零
  */
uint8_t Serial_GetRxFlag(void)
{
	if (Serial_RxFlag == 1)			//如果标志位为1
	{
		Serial_RxFlag = 0;
		return 1;					//则返回1，并自动清零标志位
	}
	return 0;						//如果标志位为0，则返回0
}

/**
  * 函    数：获取串口接收的数据
  * 参    数：无
  * 返 回 值：接收的数据，范围：0~255
  * 思想：主要是把在RxData返回给主函数
  */
uint8_t Serial_GetRxData(void)
{
	return Serial_RxData;			//返回接收的数据变量
}
```

#### 主函数的用法

```c
/*思想：
*	先判断时候接收到了数据，然后获取数据，再将数据发送给串口
*/
if (Serial_GetRxFlag() == 1)			//检查串口接收数据的标志位
		{
			RxData = Serial_GetRxData();		//获取串口接收的数据
			Serial_SendByte(RxData);			//串口将收到的数据回传回去，用于测试
			OLED_ShowHexNum(1, 8, RxData, 2);	//显示串口接收的数据
		}
```



#### 注意

一般RX配置是浮空输入或者上拉输入，因为串口波形空闲状态时高电平，所以不适用下拉输入

### 数据包程序

#### 难点

串口的接收会比发送难很多，因为每一个数据的接收都会进中断，我们不知道哪一个包头，哪一个是数据，哪一个是包尾，所以我们要使用状态机的方式来接收一个数据包。

#### 流程

最开始，标志位S=0，收到一个数据进中断，根据S=0，判断数据是不是包头FF,如果是FF，则代表是包头，之后置S=1，退出中断，结束。如果S=0，而数据不是FF，此时应该等待包头。

当S=1，进入接收状态，再建立一个变量来知道接收了多少个数据，没受够4个则一直处于接收状态，直至收齐4个，S=2。

当S=2，则判断是不是包尾，如果是则置S=0，重复。



## I2C通信

### 简介

本质是对外设的寄存器进行读写操作000

•I2C（Inter IC Bus）是由Philips公司开发的一种通用数据总线

•两根通信线：SCL（Serial Clock）、SDA（Serial Data）

•同步，半双工

•带数据应答

•支持总线挂载多设备（一主多从、多主多从）

> 一主多机：一个单片机和多个外挂设备
>
> 多主多从：在总线上任何一个模块都可以主动的当主机，但是同一时间只能有一个主机

### STM32外设资源

•STM32内部集成了硬件I2C收发电路，可以由硬件自动执行时钟生成、起始终止条件生成、应答位收发、数据收发等功能，减轻CPU的负担

•支持多主机模型

•支持7位/10位地址模式

•支持不同的通讯速度，标准速度(高达100 kHz)，快速(高达400 kHz)

•支持DMA

•兼容SMBus协议

•STM32F103C8T6 硬件I2C资源：I2C1、I2C2



### 硬件电路

•所有I2C设备的SCL连在一起，SDA连在一起

•设备的SCL和SDA均要配置成开漏输出模式

•SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291046.png)

一主多从的模式下，主机有SCL的绝对控制权，从机不允许控制SCL线。

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291055.png)

当上面的电源存在时就是推挽输出，上开关导通，则输出高电平，下开关导通，则输出低电平，具有强上拉和强下拉作用。

当上面的电源不存在时就是开漏输出模式，下面导通是强下拉，输出低电平。下面断开则是浮空状态，由外置的电阻拉到高电平的，则是弱上拉。

### I^2^C框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/130943.png)

> 当数据由数据寄存器转到移位寄存器时，会置状态寄存器的TXE位为1.
>
> 当数据由SDA移到移位寄存器时，会置状态寄存器的RXNE位为1.



### I^2^C基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/130952.png)

### 时序

#### I2C时序基本单元

•起始条件：SCL高电平期间，SDA从高电平切换到低电平

•终止条件：SCL高电平期间，SDA从低电平切换到高电平

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291100.png)

> 起始条件中，将SDA拉低后又将SCL拉低的原因是好对接接下来的时序。

•发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上（高位先行），然后释放SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291103.png)

> 当SCL拉到高电平的时候，也是从机读取SDA数据线的时候。
>
> 当传输到一半时，如果主机进中断，则SCL和SDA不会变化，当主机继续传输时SCL和SDA才会继续变化，所以传输不会出现问题。
>
> 注意是高位先行。



•接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291108.png)

> 释放SDA就是重新将SDA上拉。



•发送应答：主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答

•接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291111.png)

#### 指定地址写

•对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291118.png)

> 指定设备，是设备的地址（设备的地址一般都是7位的），所以环境帧的8位一般都由设备地址和读写位组成。
>
> 指定地址，是设备里面寄存器的地址
>
> 最开时的一帧数据是指定设备地址和设置读写操作，如上，第一帧前7位是地址，后一位是读写
>
> 读写操作位：0表示之后的时序主机写入，1表示之后的时序主机进行读出操作。
>
> 在应答位，主机应当是释放SDA的，但是读取的时候SDA是低电平，说明有设备应答。
>
> 整个流程： 起始位+环境帧+应答位+储存器地址+应答位+数据帧+应答位+······+终止位
>
> 如果想多发送几个字节，则多重复上面最后一个数据帧，再拉终止位。但是每写入一个数据，地址指针都会自增，所以每次写入都是上一个地址的下一个。



#### 当前地址读

•对于指定设备（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291130.png)

> 读写位为1，说明主机接下来要读取数据。
>
> 当主机在读写位值1，则立马失去了对SDA的控制权，来不及指定地址，而寄存器发送哪个寄存器的值则由地址指针决定。从机中的地址会被分配到一个线性寄存器。地址指针上电后是0，会在每一次发送数据后+1。
>
> 如果想多读几次，则多重复最后一部分时序。



#### 指定地址读

•对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1291135.png)

> 刚开始用写，写入地址后重新拉一个起始标志位，而地址指针已经在前一帧写入的时候发生了改变。则读的时候就能在自己指定的地址读出来。
>
> 当想要结束时，一定要在最后一个应答位拉高，发送非应答，则从机才会停止发送。因为此时SDA不受我们控制，要想发送终止位，则必须先拿回SDA的控制权，发送非应答后就可以拿回SDA的控制权了。

### 软件I2C

```c
void MyI2C_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	//开启GPIOB的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);					//将PB10和PB11引脚初始化为开漏输出
	
	/*设置默认电平*/
	GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11);			//设置PB10和PB11引脚初始化后默认为高电平（释放总线状态）
}
```

软件的I2C其实就是两个GPIO引脚用作开漏输出模式，根据I2C的时序翻转电平以达到通信的原理





### 硬件I^2^C程序

#### 流程图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/130956.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/130957.png)

> 当数据寄存器数据满时，置状态寄存器中的RxNE标志位为1.

#### 步骤

* 开启I^2^C外设和对应GPIO口的时钟
* 把I^2^C外设对应的GPIO口初始化为复用开漏模式
* 使用结构体，对I^2^C进行配置
* 使能I^2^C

#### 函数库

```c
/*定义*/
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);

/*结构体初赋值*/
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);

/*结构体成员*/
I2C_InitTypeDef I2C_InitStruct;
I2C_InitStructure.I2C_Mode //I2C模式
I2C_InitStructure.I2C_ClockSpeed  //时钟速度
I2C_InitStructure.I2C_DutyCycle   //时钟占比
I2C_InitStructure.I2C_Ack //应答位
I2C_InitStructure.I2C_AcknowledgedAddress  //应答地址

/*I2C使能*/
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);

/*生成起始条件*/
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);

/*生成终止条件*/
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);

/*主机收到数据后是否给应答*/
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);

/*发送数据*/
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);

/*接收数据*/
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);

/*发送7位地址*/
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);

/*监控I2C状态*/  //类似于流程图中的EV事件
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);

/*查看标志位状态*/
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);

/*清除标志位*/
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);

/*读取中断标志位*/
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);

/*清除中断标志位*/
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);

/*
I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       	    : EV1
I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED           		: EV1
I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED  		: EV1
I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    	    : EV1
I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED      	    : EV1
I2C_EVENT_SLAVE_BYTE_RECEIVED                     	    : EV2
(I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)  	    : EV2
(I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)  	: EV2
I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  	    : EV3
(I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)     : EV3
(I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)   : EV3
I2C_EVENT_SLAVE_ACK_FAILURE                             : EV3_2
I2C_EVENT_SLAVE_STOP_DETECTED                           : EV4
I2C_EVENT_MASTER_MODE_SELECT                            : EV5
I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED              : EV6     
I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED                 : EV6
I2C_EVENT_MASTER_BYTE_RECEIVED                          : EV7
I2C_EVENT_MASTER_BYTE_TRANSMITTING                      : EV8
I2C_EVENT_MASTER_BYTE_TRANSMITTED                       : EV8_2
I2C_EVENT_MASTER_MODE_ADDRESS10                         : EV9
  */
```

#### 环境配置

```c
void MyI2C_Init()
{
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);		//开启I2C2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		//开启GPIOB的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);					//将PB10和PB11引脚初始化为复用开漏输出
	
	/*I2C初始化*/
	I2C_InitTypeDef I2C_InitStructure;						//定义结构体变量
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;				//模式，选择为I2C模式
	I2C_InitStructure.I2C_ClockSpeed = 50000;				//时钟速度，选择为50KHz
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;		//时钟占空比，选择Tlow/Thigh = 2
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;				//应答，选择使能
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;	//应答地址，选择7位，从机模式下才有效
	I2C_InitStructure.I2C_OwnAddress1 = 0x00;				//自身地址，从机模式下才有效
	I2C_Init(I2C2, &I2C_InitStructure);						//将结构体变量交给I2C_Init，配置I2C2
	
	/*I2C使能*/
	I2C_Cmd(I2C2, ENABLE);									//使能I2C2，开始运行
}
```

#### 检查EV事件

```c
void MyI2C_WaitEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
	uint32_t Timeout;
	Timeout = 10000;									//给定超时计数时间
	while (I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS)	//循环等待指定事件
	{
		Timeout --;										//等待时，计数值自减
		if (Timeout == 0)								//自减到0后，等待超时
		{
			/*超时的错误处理代码，可以添加到此处*/
			break;										//跳出等待，不等了
		}
	}
}
```

> while是确保发送完毕,但是容易将程序卡死，所以要加一个定时退出while

#### 发送数据

```c
void MyI2C_WriteReg(uint8_t RegAddress, uint8_t Data)
{
	I2C_GenerateSTART(I2C2, ENABLE);										//硬件I2C生成起始条件
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					//等待EV5
	
	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);	//硬件I2C发送从机地址，方向为发送
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);	//等待EV6
	
	I2C_SendData(I2C2, RegAddress);											//硬件I2C发送寄存器地址
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING);			//等待EV8
	
	I2C_SendData(I2C2, Data);												//硬件I2C发送数据
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);				//等待EV8_2
	
	I2C_GenerateSTOP(I2C2, ENABLE);											//硬件I2C生成终止条件
}
```

#### 接收数据

```c
uint8_t MyI2C_ReadReg(uint8_t RegAddress)
{
	uint8_t Data;
	
	I2C_GenerateSTART(I2C2, ENABLE);										//硬件I2C生成起始条件
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					//等待EV5
	
	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);	//硬件I2C发送从机地址，方向为发送
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);	//等待EV6
	
	I2C_SendData(I2C2, RegAddress);											//硬件I2C发送寄存器地址
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);				//等待EV8_2
	
	I2C_GenerateSTART(I2C2, ENABLE);										//硬件I2C生成重复起始条件
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);					//等待EV5
	
	I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Receiver);		//硬件I2C发送从机地址，方向为接收
	MyI2C_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);		//等待EV6
	
	I2C_AcknowledgeConfig(I2C2, DISABLE);									//在接收最后一个字节之前提前将应答失能
	I2C_GenerateSTOP(I2C2, ENABLE);											//在接收最后一个字节之前提前申请停止条件
	
	MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED);				//等待EV7
	Data = I2C_ReceiveData(I2C2);											//接收数据寄存器
	
	I2C_AcknowledgeConfig(I2C2, ENABLE);									//将应答恢复为使能，为了不影响后续可能产生的读取多字节操作
	
	return Data;
}
```

#### 一字节发送和接收

```c
void Track_Write(uint8_t RegAddress, uint8_t Data)
{
	I2C_GenerateSTART(I2C2, ENABLE);  //发送起始信号
	WaitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);  //等待EV5事件
	 
	I2C_Send7bitAddress(I2C2, RegAddress, I2C_Direction_Transmitter);  //发送设备地址啊，方向为发送
	WaitEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);  //等待发送的EV6事件
	
	I2C_SendData(I2C2, Data);           //发送数据
	WaitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED);  //等待EV8_2事件
	I2C_GenerateSTOP(I2C2, ENABLE);    //发送结束信号
}



uint8_t Track_Read(uint8_t RegAddress)
{
	uint8_t Data;
	I2C_GenerateSTART(I2C2, ENABLE);    //发送起始信号
	WaitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);   //等待EV5事件
	I2C_Send7bitAddress(I2C2, 0x4F<<1, I2C_Direction_Receiver);  //发送设备地址，方向为接收
	WaitEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);  //等待接收的EV6事件
	
	I2C_AcknowledgeConfig(I2C2, DISABLE);   //主机收到数据后取消应答，通常用在最后一个数据
	I2C_GenerateSTOP(I2C2, ENABLE);  //发送终止信号
	WaitEvent(I2C2,I2C_EVENT_MASTER_BYTE_RECEIVED);  //等待EV7事件
	
	Data=I2C_ReceiveData(I2C2);
	return Data;
}
```



## SPI通信

### 简介

•SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线

•四根通信线：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）

•同步，全双工 

•支持总线挂载多设备（一主多从）

> SCK：串行时钟线
>
> MOSI:主机输出从机输入
>
> MISO:主机输入从机输出
>
> SS:从机选择

### 硬件电路

•所有SPI设备的SCK、MOSI、MISO分别连在一起

•主机另外引出多条SS控制线，分别接到各从机的SS引脚

•输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311006.png)

> SCK时钟线，由主机掌控。对主机来说，SCK输出，对于所有从机来说，时钟线都为输入。

### 移位示意图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311012.png)

* 硬件电路核心

> 通过波特率发生器，所有寄存器往左移位，直到交换数据，这样子就可以做到即发送又接收。

### SPI时序基本单元

•起始条件：SS从高电平切换到低电平

•终止条件：SS从低电平切换到高电平

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311019.png)

•交换一个字节（模式0）

•CPOL=0：空闲状态时，SCK为低电平

•CPHA=0：SCK第一个边沿移入数据，第二个边沿移出数据

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311020.png)

> 从SS的下降沿就开始将数据放在数据线上，当SCK上升沿就交换数据，然后下降沿再把数据放在数据线上。
>
> CPOL是SCK的极性问题。

•交换一个字节（模式1）

•CPOL=0：空闲状态时，SCK为低电平

•CPHA=1：SCK第一个边沿移出数据，第二个边沿移入数据

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311021.png)

>  从SCK的上升沿就开始将数据放在数据线上，当SCK下降沿就交换数据，然后上升沿沿再把数据放在数据线上。

•交换一个字节（模式2）

•CPOL=1：空闲状态时，SCK为高电平

•CPHA=0：SCK第一个边沿移入数据，第二个边沿移出数据

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311022.png)

•交换一个字节（模式3）

•CPOL=1：空闲状态时，SCK为高电平

•CPHA=1：SCK第一个边沿移出数据，第二个边沿移入数据

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311023.png)

### SPI时序

•发送指令

•向SS指定的设备，发送指令（0x06）

<img src="https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311031.png" style="zoom:170%;" />

•指定地址写

•向SS指定的设备，发送写指令（0x02），

   随后在指定地址（Address[23:0]）下，写入指定数据（Data）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311035.png)

•指定地址读

•向SS指定的设备，发送读指令（0x03），

   随后在指定地址（Address[23:0]）下，读取从机数据（Data）

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/1311038.png)

### SPi外设简介

•STM32内部集成了硬件SPI收发电路，可以由硬件自动执行时钟生成、数据收发等功能，减轻CPU的负担

•可配置8位/16位数据帧、高位先行/低位先行

•时钟频率： fPCLK / (2, 4, 8, 16, 32, 64, 128, 256)

•支持多主机模型、主或从操作

•可精简为半双工/单工通信

•支持DMA

•兼容I2S协议

STM32F103C8T6 硬件SPI资源：SPI1、SPI2	

### SPI基本外设

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/211511.png)

### 主模式全双工连续传输

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/211512.png)





# RTC实时时钟

## 简介

•RTC（Real Time Clock）实时时钟

•RTC是一个独立的定时器，可为系统提供时钟和日历的功能

•RTC和时钟配置系统处于后备区域，系统复位时数据不清零，VDD（2.0 ~ 3.6V）断电后可借助VBAT（1.8 ~ 3.6V）供电继续走时

•32位的可编程计数器，可对应Unix时间戳的秒计数器

•20位的可编程预分频器，可适配不同频率的输入时钟

•可选择三种RTC时钟源：

 HSE时钟除以128（通常为8MHz/128）

 LSE振荡器时钟（通常为32.768KHz）

 LSI振荡器时钟（40KHz）

> 只有LSE时钟可以通过VBAT备用电源供电的

## 框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/231450.png)

> 灰色区域为后备区域

## 基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/231505.png)

## 硬件电路

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/231507.png)

## RTC操作注意事项

•执行以下操作将使能对BKP和RTC的访问：

 设置RCC_APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟

 设置PWR_CR的DBP，使能对BKP和RTC的访问

•若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位（寄存器同步标志）被硬件置1

•必须设置RTC_CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器

•对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器

## 程序

### 思路

> 设置RCC_APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟
>
>  设置PWR_CR的DBP，使能对BKP和RTC的访问
>
> 启动RTC时钟（如果选择LSE时钟，其默认是关闭的，需要在RCC中打开时钟）
>
> 配置RTCCLK数据选择器，指定时钟源
>
> 等待同步
>
> 给PRL重装寄存器合适的分频值
>
> 配置CNT的值

### 库函数

```c
/*打开时钟*/
void RCC_LSEConfig(uint8_t RCC_LSE);
void RCC_LSICmd(FunctionalState NewState);

/*对时钟源进行配置*/
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
void RCC_RTCCLKCmd(FunctionalState NewState);

/*RCC中断标志位*/
ITStatus RCC_GetITStatus(uint8_t RCC_IT);//(这里的中断标志位是指上面的时钟源成功打开了)

/*配置中断输出*/
void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState);

/*进入配置模式*/
void RTC_EnterConfigMode(void);

/*退出配置模式*/
void RTC_ExitConfigMode(void);

/*获取CNT的值*/
uint32_t  RTC_GetCounter(void);

 /*写入CNT的值*/
void RTC_SetCounter(uint32_t CounterValue);

/*配置分频器的分频系数*/
void RTC_SetPrescaler(uint32_t PrescalerValue);

/*写入闹钟值*/
void RTC_SetAlarm(uint32_t AlarmValue);

/*获取余数寄存器的值*/
uint32_t  RTC_GetDivider(void);

/*等待上次操作完成*/
void RTC_WaitForLastTask(void);

/*等待同步*/
void RTC_WaitForSynchro(void);

/*获取标志位*/
FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG);

/*清除标志位*/
void RTC_ClearFlag(uint16_t RTC_FLAG);

/*获取中断标志位*/
ITStatus RTC_GetITStatus(uint16_t RTC_IT);

/*清除中断标志位*/
void RTC_ClearITPendingBit(uint16_t RTC_IT);

```



# Unix时间戳

•Unix 时间戳（Unix Timestamp）定义为从UTC/GMT的1970年1月1日0时0分0秒开始所经过的秒数，不考虑闰秒

•时间戳存储在一个秒计数器中，秒计数器为32位/64位的整型变量

•世界上所有时区的秒计数器相同，不同时区通过添加偏移来得到当地时间

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/23945.png)

## 时间戳转换

•C语言的time.h模块提供了时间获取和时间戳转换的相关函数，可以方便地进行秒计数器、日期时间和字符串之间的转换

```c
time_t time(time_t*); //获取系统时钟

struct tm* gmtime(const time_t*);//秒计数器转换为日期时间（格林尼治时间）

struct tm* localtime(const time_t*);//秒计数器转换为日期时间（当地时间）

time_t mktime(struct tm*);//日期时间转换为秒计数器（当地时间）

char* ctime(const time_t*);//秒计数器转换为字符串（默认格式）

char* asctime(const struct tm*);//日期时间转换为字符串（默认格式）

size_t strftime(char*, size_t, const char*, const struct tm*);//日期时间转换为字符串（自定义格式）

```

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/231004.png)

## UTC/GMT

 •GMT（Greenwich Mean Time）格林尼治标准时间是一种以地球自转为基础的时间计量系统。它将地球自转一周的时间间隔等分为24小时，以此确定计时标准

•UTC（Universal Time Coordinated）协调世界时是一种以原子钟为基础的时间计量系统。它规定铯133原子基态的两个超精细能级间在零磁场下跃迁辐射9,192,631,770周所持续的时间为1秒。当原子钟计时一天的时间与地球自转一周的时间相差超过0.9秒时，UTC会执行闰秒来保证其计时与地球自转的协调一致

# BKP

## 简介

•BKP（Backup Registers）备份寄存器

•BKP可用于存储用户应用程序数据。当VDD（2.0 ~ 3.6V）电源被切断，他们仍然由VBAT（1.8 ~ 3.6V）维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位

•TAMPER引脚产生的侵入事件将所有备份寄存器内容清除

•RTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲

•存储RTC时钟校准寄存器

•用户数据存储容量：

 20字节（中容量和小容量）/ 84字节（大容量和互联型）

## BKP基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/231426.png)

> 当VDD主电源掉电时，后备区域仍然可以由VBAT的备用电池供电
>
> 当VDD主电源上电时，后备区域供电会由VBAT切换到VDD
>
> 小容量有DR1-DR10的寄存器，大容量包括到以后的DR42

## 程序

### 思路

> 使能PWR和BKP时钟
>
> 设置PWR_CR的DBP，使能对BKP和RTC的访问
>
> 用BKP的函数对数据进行读写和写入

### 函数库

```c
/*恢复初始设置，手动清空寄存器数据*/
void BKP_DeInit(void);

/*设置PWR_CR的DBP，使能对BKP和RTC的访问*/
void PWR_BackupAccessCmd(FunctionalState NewState);

/*写备份寄存器*/
void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data);

/*读备份寄存器*/
uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR);

/*获取标志位*/
FlagStatus BKP_GetFlagStatus(void);

/*清除标志位*/
void BKP_ClearFlag(void);

/*获取中断标志位*/
ITStatus BKP_GetITStatus(void);

/*清除中断标志位*/
void BKP_ClearITPendingBit(void);

/*配置TAMPER浸入检测功能*/
void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel);
void BKP_TamperPinCmd(FunctionalState NewState);

/*中断使能*/
void BKP_ITConfig(FunctionalState NewState);

/*选择时钟输出功能*/
void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource);

/*设置RTC校准值，写入RTC值*/
void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue);
```



# PWR电源控制

## 简介

•PWR（Power Control）电源控制

•PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能

•可编程电压监测器（PVD）可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务

低功耗模式包括睡眠模式（Sleep）、停机模式（Stop）和待机模式（Standby），可在系统空闲时，降低STM32的功耗，延长设备使用时间

## 电源框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/26928.png)

## 上电复位

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/26934.png)

* 详细数据参考芯片数据手册

## 可编程电压检测器

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/26935.png)

* 与上电复电的区别在于此时的PVD阈值可以使用程序指定的
* 调节范围参考芯片数据手册

## 低功耗模式

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/26940.png)

> 停机：
>
> PDDS位是用来区分是停机模式还是待机模式，PDDS=0为停机模式，PDDS=1为待机模式
>
> LPDS是用来控制电压调节器。LPDS=0，开启电压调节器、LPDS=1，电压调节器进入低功耗模式
>
> SLEEPDEEP位是用来进入深度睡眠的

## 模式选择

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/26954.png)

•执行WFI（Wait For Interrupt）或者WFE（Wait For Event）指令后，STM32进入低功耗模式

## 睡眠模式

•执行完WFI/WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行

•SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠，还是等STM32从最低优先级的中断处理程序中退出时进入睡眠

•在睡眠模式下，所有的I/O引脚都保持它们在运行模式时的状态

•WFI指令进入睡眠模式，可被任意一个NVIC响应的中断唤醒

•WFE指令进入睡眠模式，可被唤醒事件唤醒



## 停止模式

•执行完WFI/WFE指令后，STM32进入停止模式，程序暂停运行，唤醒后程序从暂停的地方继续运行

•1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，SRAM和寄存器内容被保留下来

•在停止模式下，所有的I/O引脚都保持它们在运行模式时的状态

•当一个中断或唤醒事件导致退出停止模式时，HSI被选为系统时钟

•当电压调节器处于低功耗模式下，系统从停止模式退出时，会有一段额外的启动延时

•WFI指令进入停止模式，可被任意一个EXTI中断唤醒

•WFE指令进入停止模式，可被任意一个EXTI事件唤醒



## 待机模式

•执行完WFI/WFE指令后，STM32进入待机模式，唤醒后程序从头开始运行

•整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电

•在待机模式下，所有的I/O引脚变为高阻态（浮空输入）

•WKUP引脚的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式

## 程序

### 函数库

```c
/*恢复初始配置*/
void PWR_DeInit(void);

/*打开PWR时钟线*/
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);

/*使能后备区域的访问*/
void PWR_BackupAccessCmd(FunctionalState NewState);

/*配置PVD的阈值电压*/
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);

/*使能PVD功能*/
void PWR_PVDCmd(FunctionalState NewState);

/*使能位于PA0位置的WKUP引脚*/
void PWR_WakeUpPinCmd(FunctionalState NewState);

/*进入停止模式*/
void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);

/*进入待机模式*/
void PWR_EnterSTANDBYMode(void);

/*获取标志位*/
FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);

/*清除标志位*/
void PWR_ClearFlag(uint32_t PWR_FLAG);

```

# 看门狗

### 简介

•WDG（Watchdog）看门狗

•看门狗可以监控程序的运行状态，当程序因为设计漏洞、硬件故障、电磁干扰等原因，出现卡死或跑飞现象时，看门狗能及时复位程序，避免程序陷入长时间的罢工状态，保证系统的可靠性和安全性

•看门狗本质上是一个定时器，当指定时间范围内，程序没有执行喂狗（重置计数器）操作时，看门狗硬件电路就自动产生复位信号

•STM32内置两个看门狗

 独立看门狗（IWDG）：独立工作，对时间精度要求较低

 窗口看门狗（WWDG）：要求看门狗在精确计时窗口起作用

## IWDG

### 框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/27942.png)

### 超出时间

•超时时间：TIWDG = TLSI × PR预分频系数 × (RL + 1)

•其中：TLSI = 1 / FLSI

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/27958.png)

### 键寄存器

 •键寄存器本质上是控制寄存器，用于控制硬件电路的工作

•在可能存在干扰的情况下，一般通过在整个键寄存器写入特定值来代替控制寄存器写入一位的功能，以降低硬件电路受到干扰的概率

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/27947.png)

### 程序

#### 步骤

* 打开LSI时钟线(不需要写代码)
* 写入键值接触写保护
* 写入预分频器和重装寄存器
* 写入键值启动看门狗
* 在程序中不断输入指令喂狗

#### 函数库

```c
 /*写使能*/
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);

/*写入预分频器*/
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);

/*写入重装值*/
void IWDG_SetReload(uint16_t Reload);

/*重新装载寄存器，即喂狗*/
void IWDG_ReloadCounter(void);

/*看门狗使能*/
void IWDG_Enable(void);

/*获取标志位状态*/
FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);

/*查看是看门狗导致的复位还是人为复位*/
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);

/*清除RCC标志位*/
void RCC_ClearFlag(void);
```



## WWDG

### 框图

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/27959.png)

> CFR寄存器存放时间

> 如果将T6也当作计数器，则计数器减到0x40则触发复位
>
> 如果将T6当作标志位，则低6位减到0时，标志位置0，触发复位。

### 超过时间

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/27959.png)

•超时时间：

 TWWDG = TPCLK1 × 4096 × WDGTB预分频系数 × (T[5:0] + 1)

•窗口时间：

 TWIN = TPCLK1 × 4096 × WDGTB预分频系数 × (T[5:0] - W[5:0])

•其中：TPCLK1 = 1 / FPCLK1

### 程序

#### 步骤

* 开启窗口看门狗的时钟，APB1
* 配置寄存器
* 写入控制寄存器CR
* 后面不断载入CNT值进行喂狗即可

#### 函数库

```c
/*写入预分频值*/
void WWDG_SetPrescaler(uint32_t WWDG_Prescaler);

/*写入窗口值*/
void WWDG_SetWindowValue(uint8_t WindowValue);

/*使能中断*/
void WWDG_EnableIT(void);

/*写入寄存器*/
void WWDG_SetCounter(uint8_t Counter);

/*使能窗口看门狗*/
void WWDG_Enable(uint8_t Counter);

/*状态标志位*/
FlagStatus WWDG_GetFlagStatus(void);

/*清除标志位*/
void WWDG_ClearFlag(void);

/*查看是看门狗导致的复位还是人为复位*/
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);

/*清除RCC标志位*/
void RCC_ClearFlag(void);
```



## IWDG和WWDG区别

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/271017.png)

# FLASH

## 简介

•STM32F1系列的FLASH包含程序存储器、系统存储器和选项字节三个部分，通过闪存存储器接口（外设）可以对**程序存储器**和**选项字节**进行擦除和编程

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241120085107.jpg)

•读写FLASH的用途：

 利用程序存储器的剩余空间来保存掉电不丢失的用户数据

 通过在程序中编程（IAP），实现程序的自我更新

•在线编程（In-Circuit Programming – ICP）用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序（Bootloader）下载程序

•在程序中编程（In-Application Programming – IAP）可以使用微控制器支持的任一种通信接口下载程序

## 闪存模块组织

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/271853.png)

> 擦除和编程都是以页为单位。
>
> 擦除即是全置1.
>
> 擦除只能1写0，不能0写1
>
> 擦除和写入之后都需要等待忙
>
> 主存储器的页开始地址都是以000、400、800、C00结尾的

## FLASH基本结构

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/271858.png)

## FLASH解锁

•FPEC共有三个键值：

 RDPRT键 = 0x000000A5

 KEY1 = 0x45670123

 KEY2 = 0xCDEF89AB

•解锁：

 复位后，FPEC被保护，不能写入FLASH_CR

 在FLASH_KEYR先写入KEY1，再写入KEY2，解锁

 错误的操作序列会在下次复位前锁死FPEC和FLASH_CR

•加锁：

 设置FLASH_CR中的LOCK位锁住FPEC和FLASH_CR

## 使用指针访问存储器

•使用指针读指定地址下的存储器：

 uint16_t Data = *((__IO uint16_t *)(0x08000000));

> (__IO uint16_t *)-->是强制类型转换，将0x08强制转换为uint16_t *的格式
>
> 访问寄存器不需要对寄存器进行解锁，直接能读

•使用指针写指定地址下的存储器：

 *((__IO uint16_t *)(0x08000000)) = 0x1234;



•其中：

 \#define  __IO  volatile

> stm32芯片会对程序进行优化 而volatile可以告诉芯片原封不动的执行语句，不要优化
>
> 例如：如果频繁读取某一个变量，芯片会将变量放在高速缓存区，以便快读读取，但是如果中断中改变了该值但是没写入告诉缓存区，就会导致读取的还是以前的值

## 程序存储器

### 程序存储器编程

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/271908.png)

### 程序存储器页擦除

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/2710909.png)

### 程序存储器全擦除

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/271910.png)

## 选项字节

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/271912.png)

•RDP：写入RDPRT键（0x000000A5）后解除读保护

•USER：配置硬件看门狗和进入停机/待机模式是否产生复位

•Data0/1：用户可自定义使用

•WRP0/1/2/3：配置写保护，每一个位对应保护4个存储页（中容量）

### 选项字节擦除

•检查FLASH_SR的BSY位，以确认没有其他正在进行的闪存操作

•解锁FLASH_CR的OPTWRE位

•设置FLASH_CR的OPTER位为1

•设置FLASH_CR的STRT位为1

•等待BSY位变为0

•读出被擦除的选择字节并做验证

### 选项字节编程

•检查FLASH_SR的BSY位，以确认没有其他正在进行的编程操作

•解锁FLASH_CR的OPTWRE位

•设置FLASH_CR的OPTPG位为1

•写入要编程的半字到指定的地址

•等待BSY位变为0

•读出写入的地址并验证数据

## 程序

```c
/*解锁*/
void FLASH_Unlock(void);

/*上锁*/
void FLASH_Lock(void);

/*闪存擦除某一页*/
FLASH_Status FLASH_ErasePage(uint32_t Page_Address);

/*全擦除*/
FLASH_Status FLASH_EraseAllPages(void);

/*擦除选项字节*/
FLASH_Status FLASH_EraseOptionBytes(void);

/*在指定地址写入字*/
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);

/*在指定地址写入半字*/
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);

/*获取用户选项的三个配置位*/
uint32_t FLASH_GetUserOptionByte(void);

/*获取写保护状态*/
uint32_t FLASH_GetWriteProtectionOptionByte(void);

/*获取读保护状态*/
FlagStatus FLASH_GetReadOutProtectionStatus(void);

/*中断使能*/
void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);

/*获取标志位*/
FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);

/*清除标志位*/
void FLASH_ClearFlag(uint32_t FLASH_FLAG);

/*获取状态*/
FLASH_Status FLASH_GetStatus(void);

/*等待操作，等待忙*/
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
```



# 器件电子签名

•电子签名存放在闪存存储器模块的系统存储区域，包含的芯片识别信息在出厂时编写，不可更改，使用指针读指定地址下的存储器可获取电子签名

•

•闪存容量寄存器：

 基地址：0x1FFF F7E0

 大小：16位



•产品唯一身份标识寄存器：

 基地址： 0x1FFF F7E8

 大小：96位





# 算法

## 二位式控制算法

工作流程：

用户设置的期望值 ---> 位式控制算法-->STM32--->对象

​                                             ↑ <——传感器<————↓

例如控温系统

> 用户设置一个期望值，例如70度，这个值传给控制算法，对象通过传感器将值回传给算法，通过比较之类的，算法的结果再传给STM32，STM32在执行操作使温度降低。

特点：

> 位式控制算法的输出非常单一，只有高电平和低电平。

## PID算法

### 介绍

PID即：Proportional（比例）、Integral（积分）、Differential（微分）的缩写。

顾名思义，PID控制算法是结合比例、积分和微分三种环节于一体的控制算法，它是连续系统中技术最为成熟、应用最为广泛的一种控制算法，该控制算法出现于20世纪30至40年代，适用于对被控对象模型了解不清楚的场合。实际运行的经验和理论的分析都表明，运用这种控制规律对许多工业过程进行控制时，都能得到比较满意的效果。

PID控制的实质就是根据输入的偏差值，按照比例、积分、微分的函数关系进行运算，运算结果用以控制输出。 [2]在工业过程中，连续控制系统的理想PID控制规律为： 

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/232005.png)

![](https://cdn.jsdelivr.net/gh/lgdd-29/NoteBook/Notephoto/3112113.png)

式中，Kp——比例增益，Kp与比例度成倒数关系； 

Tt——积分时间常数； 

TD——微分时间常数； 

u（t）——PID控制器的输出信号； 

e（t）——给定值r（t）与测量值之差。

 

### 原理

[闭环控制](https://baike.baidu.com/item/闭环控制/428776?fromModule=lemma_inlink)是根据控制对象输出反馈来进行校正的控制方式，它是在测量出实际与计划发生偏差时，按定额或标准来进行纠正的。比如控制一个电机的转速，就得有一个测量转速的传感器，并将结果反馈到控制路线上。提到闭环控制算法，不得不提PID，它是闭环控制算法中最简单的一种。PID是比例 (Proportion) 积分 ,(Integral) 微分 ,(Differential coefficient) 的缩写，分别代表了三种控制算法。通过这三个算法的组合可有效地纠正被控制对象的偏差，从而使其达到一个稳定的状态

### 比例算法

成比例地反映控制系统的偏差信号，偏差一旦产生，立即产生控制作用以减小偏差。[比例控制器](https://baike.baidu.com/item/比例控制器/318517?fromModule=lemma_inlink)的输出u(t)与输入偏差e(t)成正比，能迅速反映偏差，从而减小偏差，但不能消除静差。静差是指[系统控制](https://baike.baidu.com/item/系统控制/16142297?fromModule=lemma_inlink)过程趋于稳定时，给定值与输出量的实测值之差。偏差存在，才能使控制器维持一定的控制量输出，因此比例控制器必然存在着静差。由偏差理论知，增大虽然可以减小偏差，但不能彻底消除偏差。比例控制作用的大小除与偏差e(t)有关之外，还取决于比例系数Kp的大小。比例系数Kp越小，控制作用越小，系统响应越慢；反之，比例系数Kp越大，控制作用也越强，则系统响应越快。但是，Kp过大会使系统产生较大的超调和振荡，导致系统的稳定性能变差。因此，不能将Kp选取过大，应根据被控对象的特性来折中选取Kp，使系统的静差控制在允许的范围内，同时又具有较快的响应速度。

我们先说PID中最简单的比例控制，抛开其他两个不谈。还是用一个经典的例子吧。假设我有一个水缸，最终的控制目的是要保证水缸里的水位永远的维持在1米的高度。假设初始时刻，水缸里的水位是0.2米，那么当前时刻的水位和目标水位之间是存在一个误差的error，且error为0.8.这个时候，假设旁边站着一个人，这个人通过往缸里加水的方式来控制水位。如果单纯的用比例控制算法，就是指加入的水量u和误差error是成正比的。即
u=kp*error
假设kp取0.5，
那么t=1时（表示第1次加水，也就是第一次对系统施加控制），那么u=0.5*0.8=0.4，所以这一次加入的水量会使水位在0.2的基础上上升0.4，达到0.6.
接着，t=2时刻（第2次施加控制），当前水位是0.6，所以error是0.4。u=0.5*0.4=0.2，会使水位再次上升0.2，达到0.8.
如此这么循环下去，就是比例控制算法的运行方法。
可以看到，最终水位会达到我们需要的1米。
但是，单单的比例控制存在着一些不足，其中一点就是 –稳态误差！（我也是看了很多，并且想了好久才想通什么是稳态误差以及为什么有稳态误差）。
像上述的例子，根据kp取值不同，系统最后都会达到1米，只不过kp大了到达的快，kp小了到达的慢一些。不会有稳态误差。但是，考虑另外一种情况，假设这个水缸在加水的过程中，存在漏水的情况，假设每次加水的过程，都会漏掉0.1米高度的水。仍然假设kp取0.5，那么会存在着某种情况，假设经过几次加水，水缸中的水位到0.8时，水位将不会再变换！！！因为，水位为0.8，则误差error=0.2. 所以每次往水缸中加水的量为u=0.5*0.2=0.1.同时，每次加水，缸里又会流出去0.1米的水！！！加入的水和流出的水相抵消，水位将不再变化！！
也就是说，我的目标是1米，但是最后系统达到0.8米的水位就不再变化了，且系统已经达到稳定。由此产生的误差就是稳态误差了。

（在实际情况中，这种类似水缸漏水的情况往往更加常见，比如控制汽车运动，摩擦阻力就相当于是“漏水”，控制机械臂、无人机的飞行，各类阻力和消耗都可以理解为本例中的“漏水”）
所以，单独的比例控制，在很多时候并不能满足要求。

> Kp越大，控制作用越强，系统响应越快的原因是，Kp与控制器的输出成正比，如果Kp越大，则控制器的输出越强，动力越强则更快的到达指定的条件，所以响应速度快。
>
> 偏差=Sv-Pv. 即是用户期望值与当前值的差。如果没有静差，当用户期望值与当前值相等的时候，则控制器不输出，动力为0，而不能保持平衡。所以静差存在的意义为当用户期望值与当前值相等时，输出的动力可以使其趋于稳定。但是因为静差的存在，当用户期望值=当前值+静差值时候，所以就算是平衡，用户期望值和当前值也存在误差，所以需要用到I算法来修正这段误差。

#### 比例值

偏差量=目标量-小球位置（在平衡小车中，即是x轴的位置）

比例P=偏差量*比例P系数

##### 缺点

1. 数值固定
2. 不能动态的执行大小

### 积分算法

积分环节的作用，主要用于消除静差提高系统的无差度。积分作用的强弱，取决于积分时间常数Ti，Ti越大积分作用越弱，反之则越强。积分控制作用的存在与偏差e(t)的存在时间有关，只要系统存在着偏差，积分环节就会不断起作用，对输入偏差进行积分，使控制器的输出及执行器的开度不断变化，产生控制作用以减小偏差。在积分时间足够的情况下，可以完全消除静差，这时积分控制作用将维持不变。Ti越小，积分速度越快，积分作用越强。积分作用太强会使系统超调加大，甚至使系统出现振荡。

还是用上面的例子，如果仅仅用比例，可以发现存在暂态误差，最后的水位就卡在0.8了。于是，在控制中，我们再引入一个分量，该分量和误差的积分是正比关系。所以，比例+积分控制算法为：
u=kp*error+ ki∗∫ error
还是用上面的例子来说明，第一次的误差error是0.8，第二次的误差是0.4，至此，误差的积分（离散情况下积分其实就是做累加），∫error=0.8+0.4=1.2. 这个时候的控制量，除了比例的那一部分，还有一部分就是一个系数ki乘以这个积分项。由于这个积分项会将前面若干次的误差进行累计，所以可以很好的消除稳态误差（假设在仅有比例项的情况下，系统卡在稳态误差了，即上例中的0.8，由于加入了积分项的存在，会让输入增大，从而使得水缸的水位可以大于0.8，渐渐到达目标的1.0.）这就是积分项的作用。

#### 积分公式

偏差量=目标量-小车平衡位置

积分I=积分I+偏差量*积分I系数

例如：当小车一直处于前倾，则小车会逐步增加动力来使小车平衡，因为积分I有累加的效果，如果一直前倾就会使积分I的值变得很大

##### 缺点

积分I因为累加的原因，如果小车失衡，则积分I会不断的累加，导致小车溃败

改正：限制积分I的最大值和最小值，并且当小车处于平衡状态时，将积分I清零

### 微分

微分环节的作用能反映偏差信号的变化趋势（变化速率），并能在偏差信号的值变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减小调节时间。积分控制作用的引入虽然可以消除静差，但是降低了系统的响应速度，特别是对于具有较大惯性的被控对象，用PI控制器很难得到很好的动态调节品质，系统会产生较大的超调和振荡，这时可以引入微分作用。在偏差刚出现或变化的瞬间，不仅根据偏差量作出及时反应（即比例控制作用），还可以根据偏差量的变化趋势（速度）提前给出较大的控制作用（即微分控制作用），将偏差消灭在萌芽状态，这样可以大大减小系统的动态偏差和调节时间，使系统的动态调节品质得以改善。微分环节有助于系统减小超调，克服振荡，加快系统的响应速度，减小调节时间，从而改善了系统的动态性能，但微分时间常数过大，会使系统出现不稳定。微分控制作用一个很大的缺陷是容易引入高频噪声，所以在干扰信号比较严重的[流量控制系统](https://baike.baidu.com/item/流量控制系统/4449418?fromModule=lemma_inlink)中不宜引入微分控制作用。

换一个另外的例子，考虑刹车情况。平稳的驾驶车辆，当发现前面有红灯时，为了使得行车平稳，基本上提前几十米就放松油门并踩刹车了。当车辆离停车线非常近的时候，则使劲踩刹车，使车辆停下来。整个过程可以看做一个加入微分的控制策略。
微分，说白了在离散情况下，就是error的差值，就是t时刻和t-1时刻error的差，即u=kd*（error（t）-error（t-1）），其中的kd是一个系数项。可以看到，在刹车过程中，因为error是越来越小的，所以这个微分控制项一定是负数，在控制中加入一个负数项，他存在的作用就是为了防止汽车由于刹车不及时而闯过了线。从常识上可以理解，越是靠近停车线，越是应该注意踩刹车，不能让车过线，所以这个微分项的作用，就可以理解为刹车，当车离停车线很近并且车速还很快时，这个微分项的绝对值（实际上是一个负数）就会很大，从而表示应该用力踩刹车才能让车停下来。
切换到上面给水缸加水的例子，就是当发现水缸里的水快要接近1的时候，加入微分项，可以防止给水缸里的水加到超过1米的高度，说白了就是减少控制过程中的震荡。

#### 微分公式

下一次偏差量=偏差量-上一次偏差量

偏差量=目标量-小车位置

微分D=（偏差量-上一次偏差量）*微分D系数              /下一次偏差量/

用下一次偏差量提前参与的计算中，防止小车突然平衡不到，迅速施加动力



# 用法总结

## EXTI外部中断

RCC(GPIO-AFIO)——GPIO（定义）——AFIO连接（连接函数）——EXTI（定义）——NVIC（分组+定义）——中断函数

## TIM内部中断 

RCC(GPIO-TIM)——GPIO（定义）——选择时钟（选择函数）——时基单元（配置+定义+中断使能）——NVIC（分组+定义）——TIM使能（使能函数）——中断函数

## PWM

RCC(GPIO-TIM)——GPIO（定义）——选择时钟（选择函数）——时基单元（配置+定义+中断使能）——输出比较（定义）——TIM使能（使能函数）——改变占空比（函数）

## 编码器接口

RCC(GPIO-TIM)------GPIO(定义)-------选择时钟(选择函数)------时基单元（配置+定义）------输出比较（定义）-------编码器接口配置（配置函数）--------TIM使能

RCC(TIM)------选择时钟（选择函数）------时基单元（配置+定义+中断使能）-------NVIC（分组+定义）------TIm使能------中断函数

## ADC

RCC(GPIO-ADC-ADCCLK)——GPIO(定义)——注入组配置（函数）——ADC（定义-使能-校准）

# 巧妙函数封装

```c
/*-----------------Definition.h----------*/
//可以学习一下这个思路以及定义参数的名字
#ifndef	__DEFINITION_H__
#define __DEFINITION_H__
#include "stm32f10x.h"     
//定义SPI底层的结构体
typedef struct {   
    const uint16_t CS;
    const uint16_t CLK;
    const uint16_t MOSI;
    const uint16_t MISO;
    GPIO_TypeDef*  Port;   //这是定义那个GPIO的
} SPI_Pins;
//定义传感器的结构体，这个结构体要包含SPI结构体，这样子可以直接从应用层到底层一起赋值
typedef struct {
    const SPI_Pins pins;   

    const uint8_t READ_OP;
    const uint8_t WRITE_OP;
    const uint8_t DATA_REG_1;
    const uint8_t DATA_REG_2;

} MT6816_Device_t;

#endif

/*-----------------Definition.c---------------*/
#include "Definition.h"
//在.c文件中进行赋值并且名字
const MT6816_Device_t mt6816_sensor = 
{
    .pins = {
        .CS   = GPIO_Pin_4,
        .CLK  = GPIO_Pin_5,
        .MOSI = GPIO_Pin_7,
        .MISO = GPIO_Pin_6,
        .Port = GPIOA
    },
    .READ_OP   = 0x80,
    .WRITE_OP  = 0x00,
    .DATA_REG_1 = 0x03,
    .DATA_REG_2 = 0x04
};
```



